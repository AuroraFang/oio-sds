
/*
OpenIO SDS metautils
Copyright (C) 2014 Worldine, original work as part of Redcurrant
Copyright (C) 2015 OpenIO, modified as part of OpenIO Software Defined Storage

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/

#ifndef G_LOG_DOMAIN
#define G_LOG_DOMAIN "metautils"
#endif

#include "metautils.h"

#include "./AddrInfo.h"
#include "./AddrInfoSequence.h"
#include "./ArrayList.h"
#include "./ChunkInfo.h"
#include "./ChunkInfoSequence.h"
#include "./ContentList.h"
#include "./INTEGER.h"
#include "./Meta0Info.h"
#include "./Meta0InfoSequence.h"
#include "./Meta1RawContainer.h"
#include "./Meta2Property.h"
#include "./Meta2PropertySequence.h"
#include "./Meta2RawChunk.h"
#include "./Meta2RawContent.h"
#include "./Meta2RawContentHeader.h"
#include "./Meta2RawContentHeaderSequence.h"
#include "./Meta2RawContentSequence.h"
#include "./Meta2RawContentV2.h"
#include "./Meta2RawContentV2Sequence.h"
#include "./NamespaceInfo.h"
#include "./NamespaceInfoSequence.h"
#include "./Parameter.h"
#include "./ParameterSequence.h"
#include "./PathInfo.h"
#include "./PathInfoSequence.h"
#include "./Score.h"
#include "./ServiceInfo.h"
#include "./ServiceInfoSequence.h"
#include "./ServiceTag.h"

#include "./asn_SET_OF.h"

/* -------------------------------------------------------------------------- */

typedef gboolean(*abstract_converter_f) (const void *in, void *out);

typedef void (*abstract_asn_cleaner_f) (void *asn, gboolean only_content);

typedef void (*abstract_api_cleaner_f) (void *api);

struct abstract_sequence_handler_s
{
	size_t asn1_size;                     /**< sizeof() on the ASN structure */
	size_t api_size;                      /**< sizeof() on the API structure */
	void *asn1_descriptor;                /**< pointer to the descriptor generated by asn1c */
	abstract_converter_f map_ASN1_to_API; /**< conversion from API to ASN */
	abstract_converter_f map_API_to_ASN1; /**< conversion from ASN to API */
	abstract_asn_cleaner_f clean_ASN1;    /**< structure cleaner */
	abstract_api_cleaner_f clean_API;     /**< structure cleaner */
	const gchar const *type_name;         /**< Type name used in error messages */
};

#define DEFINE_BODY_MANAGER(Name,Unmarshall) \
gint Name (GError **err, gpointer udata, gint code, guint8 *body, gsize bodySize) {\
	GSList **resL, *list;\
	resL = (GSList**) udata; (void)code;\
	if (!udata || !body || !bodySize) {\
		GSETERROR(err,"Invalid parameter (%p %p %"G_GSIZE_FORMAT")", udata, body, bodySize);\
		return FALSE;\
	}\
	list=NULL;\
	if (0 >= Unmarshall (&list, body, bodySize, err)) {\
		GSETERROR (err, "Cannot unserialize the content of the reply");\
		return FALSE;\
	}\
	*resL = g_slist_concat (*resL,list);\
	return TRUE;\
}

#define DEFINE_SEQUENCE_MARSHALLER_GBA(Descr,Name) \
GByteArray* Name (GSList *list, GError **err) {\
GByteArray *gba = abstract_sequence_marshall(Descr, list, err);\
	if (!gba) { GSETERROR(err,"Serialization error"); return 0; }\
	return gba;\
}

#define DEFINE_SEQUENCE_UNMARSHALLER(Descr,Name) \
gint Name (GSList **list, const void *buf, gsize len, GError **err) {\
	if (!list || !buf || !len) {\
		GSETERROR(err,"Invalid parameter (list=%p src=%p/%"G_GSIZE_FORMAT")", list, buf, len);\
		return -1;\
	}\
	return 0 < abstract_sequence_unmarshall(Descr, list, buf, len, err);\
}

struct anonymous_sequence_s
{
	asn_anonymous_set_ list;
	asn_struct_ctx_t _asn_ctx;
};

static void api_gclean(gpointer p1, gpointer p2)
{
	abstract_api_cleaner_f cleanAPI;
	if (!p1) return;
	cleanAPI = p2;
	cleanAPI(p1);
}

static gssize
abstract_sequence_unmarshall(const struct abstract_sequence_handler_s *h,
    GSList ** list, const void *asn1_encoded, gsize asn1_encoded_size, GError ** err)
{
	gssize consumed;
	void *result = NULL;
	gint i = 0, max = 0;
	asn_dec_rval_t decRet;
	asn_codec_ctx_t codecCtx;
	struct anonymous_sequence_s *abstract_sequence;
	GSList *api_result = NULL;

	void func_free(void *d)
	{
		if (!d)
			return;
		h->clean_ASN1(d, FALSE);
	}

	if (!asn1_encoded || !list) {
		GSETERROR(err, "Invalid parameter");
		return -1;
	}

	memset(&codecCtx, 0, sizeof(asn_codec_ctx_t));
	codecCtx.max_stack_size = ASN1C_MAX_STACK;
	decRet = ber_decode(&codecCtx, h->asn1_descriptor, &(result), asn1_encoded, asn1_encoded_size);

	switch (decRet.code) {
	case RC_OK:
		abstract_sequence = (struct anonymous_sequence_s *) result;

		/*fill the list with the content of the array */
		for (i = 0, max = abstract_sequence->list.count; i < max; i++) {
			void *api_structure;

			api_structure = g_malloc0(h->api_size);
			if (!h->map_ASN1_to_API(abstract_sequence->list.array[i], api_structure)) {
				GSETERROR(err,"Element of type [%s] ASN-to-API conversion error", h->type_name);

				if (api_structure)
					h->clean_API(api_structure);

				abstract_sequence->list.free = &func_free;
				asn_set_empty(abstract_sequence);
				free(abstract_sequence);
				abstract_sequence = NULL;

				if (api_result) {
					g_slist_foreach(api_result, api_gclean, h->clean_API);
					g_slist_free(api_result);
				}
				return -1;
			}
			api_result = g_slist_prepend(api_result, api_structure);
		}

		abstract_sequence->list.free = &func_free;
		asn_set_empty(abstract_sequence);
		free(abstract_sequence);
		abstract_sequence = NULL;

		*list = g_slist_concat(*list, api_result);
		consumed = decRet.consumed;
		return consumed;

	case RC_FAIL:
		GSETERROR(err, "sequence unmarshalling error (%"G_GSIZE_FORMAT" consumed)", decRet.consumed);
		return -1;

	case RC_WMORE:
		GSETERROR(err, "sequence unmarshalling error (uncomplete)");
		return 0;
	default:
		GSETERROR(err, "Serialisation produced an unknow return code : %d", decRet.code);
		return -1;
	}

	return -1;
}

static GByteArray *
abstract_sequence_marshall(const struct abstract_sequence_handler_s * h, GSList * api_sequence, GError ** err)
{
	gboolean error_occured = FALSE;
	gsize probable_size;
	asn_enc_rval_t encRet;
	struct anonymous_sequence_s asnSeq;
	GByteArray *gba;

	int func_write(const void *b, gsize bSize, void *key)
	{
		(void) key;
		return g_byte_array_append(gba, (guint8 *) b, bSize) ? 0 : -1;
	}

	void func_free(void *d)
	{
		if (!d)
			return;
		h->clean_ASN1(d, FALSE);
	}

	void func_fill(gpointer d, gpointer u)
	{
		asn_anonymous_set_ *p_set;
		void *asn1_form;

		if (error_occured || !d)
			return;
		asn1_form = calloc(1, h->asn1_size);
		if (!h->map_API_to_ASN1(d, asn1_form)) {
			free(asn1_form);
			GSETERROR(err, "Element of type [%s] serialization failed!", h->type_name);
			error_occured = TRUE;
		} else {
			p_set = &(((struct anonymous_sequence_s *) u)->list);
			asn_set_add(_A_SET_FROM_VOID(p_set), asn1_form);
		}
	}

	probable_size = g_slist_length(api_sequence) * (h->asn1_size + 6) + 64;
	probable_size = MIN(probable_size, 4096);

	gba = g_byte_array_sized_new(probable_size);
	if (!gba) {
		GSETERROR(err, "Memory allocation failure");
		return NULL;
	}

	/*fills the ASN.1 structure */
	memset(&asnSeq, 0x00, sizeof(asnSeq));
	g_slist_foreach(api_sequence, &func_fill, &asnSeq);
	if (error_occured) {
		g_byte_array_free(gba, TRUE);
		GSETERROR(err, "list serialisation error");
		return NULL;
	}

	/*serializes the structure */
	encRet = der_encode(h->asn1_descriptor, &asnSeq, func_write, NULL);
	if (encRet.encoded == -1) {
		GSETERROR(err, "Cannot encode the ASN.1 sequence (error on %s)", encRet.failed_type->name);
		g_byte_array_free(gba, TRUE);
		asnSeq.list.free = &func_free;
		asn_set_empty(&(asnSeq.list));
		return NULL;
	}

	/*free the ASN.1 structure and the working buffer */
	asnSeq.list.free = &func_free;
	asn_set_empty(&asnSeq);
	return gba;
}

/* -------------------------------------------------------------------------- */

static void
free_OCTET_STRING(OCTET_STRING_t * os)
{
	if (!os) return;
	OCTET_STRING_free(&asn_DEF_OCTET_STRING, os, 0);
}

static int
write_in_gba(const void *b, gsize bSize, void *key)
{
	GByteArray *a = g_byte_array_append((GByteArray *) key, b, bSize);
	return a ? 0 : -1;
}

/* -------------------------------------------------------------------------- */

gboolean
simple_integer_unmarshall(const guint8 * bytes, gsize size, gint64 *api)
{
	EXTRA_ASSERT(api != NULL);

	INTEGER_t *asn = NULL;
	asn_codec_ctx_t codecCtx;
	codecCtx.max_stack_size = ASN1C_MAX_STACK;
	asn_dec_rval_t decRet = ber_decode(&codecCtx, &asn_DEF_INTEGER, (void**)&asn, bytes, size);
	if (decRet.code != RC_OK)
		return FALSE;

	asn_INTEGER_to_int64(asn, api);
	ASN_STRUCT_FREE(asn_DEF_INTEGER, asn);
	return TRUE;
}

GByteArray*
simple_integer_marshall_gba(gint64 i64, GError **err)
{
	INTEGER_t asn;
	memset(&asn, 0, sizeof(INTEGER_t));
	asn_int64_to_INTEGER(&asn, i64);

	GByteArray *result = g_byte_array_new();
	asn_enc_rval_t encRet = der_encode(&asn_DEF_INTEGER, &asn, write_in_gba, result);
	ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_INTEGER, &asn);

	if (encRet.encoded == -1) {
		GSETERROR(err, "ASN.1 encoding error");
		g_byte_array_free(result, TRUE);
		return NULL;
	}

	return result;
}

/* -------------------------------------------------------------------------- */

static gboolean
key_value_pair_ASN2API(const Parameter_t * asn, key_value_pair_t * api)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);
	if (asn->name.buf && asn->name.size)
		api->key = g_strndup((const gchar*)asn->name.buf, asn->name.size);
	else
		api->key = g_strdup("");
	api->value = g_byte_array_new();
	if (asn->value.buf && asn->value.size)
		g_byte_array_append(api->value, asn->value.buf, asn->value.size);
	return TRUE;
}

static gboolean
key_value_pair_API2ASN(const key_value_pair_t * api, Parameter_t * asn)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);
	memset(asn, 0x00, sizeof(Parameter_t));
	OCTET_STRING_fromBuf(&(asn->name), api->key, strlen(api->key));
	OCTET_STRING_fromBuf(&(asn->value), (const char*)api->value->data, api->value->len);
	return TRUE;
}

static void
key_value_pair_cleanASN(Parameter_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Parameter, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_Parameter, asn);
}

static void
free_Parameter(Parameter_t * asn_param)
{
	key_value_pair_cleanASN(asn_param, FALSE);
}

static struct abstract_sequence_handler_s descr_Parameter =
{
	sizeof(Parameter_t),
	sizeof(key_value_pair_t),
	&asn_DEF_ParameterSequence,
	(abstract_converter_f) key_value_pair_ASN2API,
	(abstract_converter_f) key_value_pair_API2ASN,
	(abstract_asn_cleaner_f) key_value_pair_cleanASN,
	(abstract_api_cleaner_f) key_value_pair_clean,
	"key_value_pair"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_Parameter, key_value_pairs_marshall_gba);
DEFINE_SEQUENCE_UNMARSHALLER(&descr_Parameter, key_value_pairs_unmarshall);

/* -------------------------------------------------------------------------- */

static gboolean
addr_info_ASN2API(const AddrInfo_t * asn, addr_info_t * api)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	guint16 port16 = 0;
	asn_INTEGER_to_uint16(&asn->port, &port16);
	api->port = g_ntohs(port16);

	switch (asn->ip.present) {
		case AddrInfo__ip_PR_ipv4:
			api->type = TADDR_V4;
			if (asn->ip.choice.ipv4.buf)
				memcpy(&(api->addr), asn->ip.choice.ipv4.buf, MIN(4, asn->ip.choice.ipv4.size));
			break;
		case AddrInfo__ip_PR_ipv6:
			api->type = TADDR_V6;
			if (asn->ip.choice.ipv6.buf)
				memcpy(&(api->addr), asn->ip.choice.ipv6.buf, MIN(16, asn->ip.choice.ipv6.size));
			break;
		case AddrInfo__ip_PR_NOTHING:
			return FALSE;
	}

	return TRUE;
}

static gboolean
addr_info_API2ASN(const addr_info_t * api, AddrInfo_t * asn)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	asn_uint16_to_INTEGER(&asn->port, g_htons(api->port));
	asn->ip.present = AddrInfo__ip_PR_NOTHING;

	switch (api->type) {
	case TADDR_V4:
		OCTET_STRING_fromBuf(&(asn->ip.choice.ipv4), (char *) &(api->addr), 4);
		asn->ip.present = AddrInfo__ip_PR_ipv4;
		break;
	case TADDR_V6:
		OCTET_STRING_fromBuf(&(asn->ip.choice.ipv6), (char *) &(api->addr), 16);
		asn->ip.present = AddrInfo__ip_PR_ipv6;
		break;
	default:
		g_assert_not_reached();
		return FALSE;
	}

	return TRUE;
}

static void
addr_info_cleanASN(AddrInfo_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_AddrInfo, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_AddrInfo, asn);
}

static void
free_AddrInfo(AddrInfo_t *asn_addr)
{
	addr_info_cleanASN(asn_addr, FALSE);
}

static struct abstract_sequence_handler_s descr_AddrInfo =
{
	sizeof(AddrInfo_t),
	sizeof(addr_info_t),
	&asn_DEF_AddrInfoSequence,
	(abstract_converter_f) addr_info_ASN2API,
	(abstract_converter_f) addr_info_API2ASN,
	(abstract_asn_cleaner_f) addr_info_cleanASN,
	(abstract_api_cleaner_f) g_free,
	"addr_info"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_AddrInfo, addr_info_marshall_gba);
DEFINE_SEQUENCE_UNMARSHALLER(&descr_AddrInfo, addr_info_unmarshall);

/* -------------------------------------------------------------------------- */

static gboolean
score_ASN2API(const Score_t * asn, score_t * api)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);
	asn_INTEGER_to_int32(&(asn->value), &(api->value));
	asn_INTEGER_to_int32(&(asn->timestamp), &(api->timestamp));
	return TRUE;
}

static gboolean
score_API2ASN(const score_t * api, Score_t * asn)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);
	asn_int32_to_INTEGER(&(asn->value), api->value);
	asn_int32_to_INTEGER(&(asn->timestamp), api->timestamp);
	return TRUE;
}

static gboolean
service_tag_ASN2API(ServiceTag_t * asn, service_tag_t * api)
{
	if (!api || !asn)
		return FALSE;

	memset(api, 0x00, sizeof(service_tag_t));

	/*name */
	memcpy(api->name, asn->name.buf, MIN(asn->name.size, (int)sizeof(api->name)));

	/*value */
	switch (asn->value.present) {
		case ServiceTag__value_PR_b:
			api->type = STVT_BOOL;
			api->value.b = asn->value.choice.b;
			return TRUE;
		case ServiceTag__value_PR_i:
			api->type = STVT_I64;
			asn_INTEGER_to_int64(&(asn->value.choice.i), &(api->value.i));
			return TRUE;
		case ServiceTag__value_PR_r:
			api->type = STVT_REAL;
			asn_REAL2double(&(asn->value.choice.r), &(api->value.r));
			return TRUE;
		case ServiceTag__value_PR_s:
			api->type = STVT_STR;
			api->value.s = g_strndup((const gchar*)asn->value.choice.s.buf, asn->value.choice.s.size);
			return TRUE;
		case ServiceTag__value_PR_macro:
			api->type = STVT_MACRO;
			api->value.macro.type = g_strndup((const gchar*)asn->value.choice.macro.type.buf, asn->value.choice.macro.type.size);
			api->value.macro.param =
				g_strndup((const gchar*)asn->value.choice.macro.param.buf, asn->value.choice.macro.param.size);
			return TRUE;
		case ServiceTag__value_PR_NOTHING:
			return FALSE;
	}
	return FALSE;
}

static gboolean
service_info_ASN2API(ServiceInfo_t * asn, service_info_t * api)
{
	if (!api || !asn)
		return FALSE;

	memset(api, 0x00, sizeof(service_info_t));

	/*header */
	memcpy(api->ns_name, asn->nsName.buf, MIN(asn->nsName.size, (int)sizeof(api->ns_name)));
	memcpy(api->type, asn->type.buf, MIN(asn->type.size, (int)sizeof(api->type)));
	addr_info_ASN2API(&(asn->addr), &(api->addr));
	score_ASN2API(&asn->score, &api->score);

	/*tags */
	if (!asn->tags)
		api->tags = g_ptr_array_new();
	else {
		api->tags = g_ptr_array_sized_new(asn->tags->list.count);
		for (int i = 0, max = asn->tags->list.count; i < max; i++) {
			service_tag_t *api_tag = g_malloc0(sizeof(service_tag_t));
			ServiceTag_t *asn_tag = asn->tags->list.array[i];
			service_tag_ASN2API(asn_tag, api_tag);
			g_ptr_array_add(api->tags, api_tag);
		}
	}

	return TRUE;
}

static gboolean
service_tag_API2ASN(service_tag_t * api, ServiceTag_t * asn)
{
	gsize name_len;

	if (!api || !asn) {
		return FALSE;
	}

	memset(asn, 0x00, sizeof(ServiceTag_t));

	/*name */
	name_len = strlen_len((const guint8*)api->name, sizeof(api->name));
	OCTET_STRING_fromBuf(&(asn->name), api->name, name_len);

	/*value */
	switch (api->type) {
	case STVT_STR:
		asn->value.present = ServiceTag__value_PR_s;
		OCTET_STRING_fromBuf(&(asn->value.choice.s), api->value.s, strlen(api->value.s));
		break;
	case STVT_BUF:
		asn->value.present = ServiceTag__value_PR_s;
		OCTET_STRING_fromBuf(&(asn->value.choice.s), api->value.buf, strlen_len((const guint8*)api->value.buf,
			sizeof(api->value.buf)));
		break;
	case STVT_REAL:
		asn->value.present = ServiceTag__value_PR_r;
		asn_double2REAL(&(asn->value.choice.r), api->value.r);
		break;
	case STVT_I64:
		asn->value.present = ServiceTag__value_PR_i;
		asn_int64_to_INTEGER(&(asn->value.choice.i), api->value.i);
		break;
	case STVT_BOOL:
		asn->value.present = ServiceTag__value_PR_b;
		asn->value.choice.b = api->value.b;
		break;
	case STVT_MACRO:
		asn->value.present = ServiceTag__value_PR_macro;
		OCTET_STRING_fromBuf(&(asn->value.choice.macro.type), api->value.macro.type,
		    strlen(api->value.macro.type));
		if (api->value.macro.param)
			OCTET_STRING_fromBuf(&(asn->value.choice.macro.param), api->value.macro.param,
			    strlen(api->value.macro.param));
		else
			OCTET_STRING_fromBuf(&(asn->value.choice.macro.param), "", 0);
		break;
	}
	return TRUE;
}

static gboolean
service_info_API2ASN(service_info_t * api, ServiceInfo_t * asn)
{
	if (!api || !asn)
		return FALSE;

	memset(asn, 0x00, sizeof(ServiceInfo_t));

	/*header */
	OCTET_STRING_fromBuf(&(asn->type), api->type, strlen_len((const guint8*)api->type, sizeof(api->type)));
	OCTET_STRING_fromBuf(&(asn->nsName), api->ns_name, strlen_len((const guint8*)api->ns_name, sizeof(api->ns_name)));
	addr_info_API2ASN(&(api->addr), &(asn->addr));
	score_API2ASN(&api->score, &asn->score);

	/*tags */
	if (api->tags) {
		service_tag_t *api_tag;
		ServiceTag_t *asn_tag;
		int i, max;

		/*init the array */
		asn->tags = calloc(1, sizeof(struct ServiceInfo__tags));

		/*fill the array */
		for (max = api->tags->len, i = 0; i < max; i++) {
			api_tag = (service_tag_t *) g_ptr_array_index(api->tags, i);
			if (!api_tag)
				continue;
			asn_tag = calloc(1, sizeof(ServiceTag_t));
			if (!asn_tag)
				continue;
			service_tag_API2ASN(api_tag, asn_tag);
			asn_set_add(&(asn->tags->list), asn_tag);
		}
	}

	return TRUE;
}

static void
free_service_tag_ASN(ServiceTag_t * tag)
{
	if (!tag)
		return;
	asn_DEF_ServiceTag.free_struct(&asn_DEF_ServiceTag, tag, 0);
}

static void
service_info_cleanASN(ServiceInfo_t * asn, gboolean only_content)
{
	if (!asn)
		return;

	if (asn->tags)
		asn->tags->list.free = free_service_tag_ASN;

	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_ServiceInfo, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_ServiceInfo, asn);
}

static void
free_ServiceInfo(ServiceInfo_t * si)
{
	service_info_cleanASN(si, FALSE);
}

static const struct abstract_sequence_handler_s descr_ServiceInfo =
{
	sizeof(ServiceInfo_t),
	sizeof(service_info_t),
	&asn_DEF_ServiceInfoSequence,
	(abstract_converter_f) service_info_ASN2API,
	(abstract_converter_f) service_info_API2ASN,
	(abstract_asn_cleaner_f) service_info_cleanASN,
	(abstract_api_cleaner_f) service_info_clean,
	"service_info"
};

GByteArray*
service_info_marshall_1(service_info_t *si, GError **err)
{
	ServiceInfo_t asn;
	asn_enc_rval_t encRet;
	GByteArray *gba;

	if (!si) {
		GSETERROR(err, "invalid parameter");
		return NULL;
	}

	if (!service_info_API2ASN(si, &asn))
		ALERT("Conversion error");

	gba = g_byte_array_sized_new(64);
	encRet = der_encode(&asn_DEF_ServiceInfo, &asn, write_in_gba, gba);
	service_info_cleanASN(&asn, TRUE);

	if (encRet.encoded == -1) {
		GSETERROR(err, "Serialization error on '%s'",
				encRet.failed_type->name);
		g_byte_array_free(gba, TRUE);
		return NULL;
	}

	return gba;
}

DEFINE_SEQUENCE_UNMARSHALLER(&descr_ServiceInfo, service_info_unmarshall);
DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_ServiceInfo, service_info_marshall_gba);

/* -------------------------------------------------------------------------- */

static gboolean
chunk_id_API2ASN(const chunk_id_t * api, ChunkId_t * asn)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);
	OCTET_STRING_fromBuf(&(asn->id), (const char*)api->id, sizeof(api->id));
	addr_info_API2ASN(&(api->addr), &(asn->addr));
	OCTET_STRING_fromBuf(&(asn->vol), api->vol, strlen_len(api->vol, sizeof(api->vol)));
	return TRUE;
}

static gboolean
chunk_id_ASN2API(const ChunkId_t * asn, chunk_id_t * api)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);
	memcpy(&(api->id), asn->id.buf, MIN((int)sizeof(api->id), asn->id.size));
	addr_info_ASN2API(&(asn->addr), &(api->addr));
	memcpy(api->vol, asn->vol.buf, MIN((int)sizeof(api->vol), asn->vol.size));
	return TRUE;
}

static gboolean
chunk_info_ASN2API(const ChunkInfo_t * asn, chunk_info_t * api)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);

	if (asn->id.vol.size <= 0 || !(asn->id.vol.buf))
		return FALSE;

	memcpy(&(api->id.id), asn->id.id.buf, MIN((int)sizeof(api->id.id), asn->id.id.size));
	addr_info_ASN2API(&(asn->id.addr), &(api->id.addr));
	memcpy(api->id.vol, asn->id.vol.buf, MIN((int)sizeof(api->id.vol), asn->id.vol.size));
	memset(api->hash, 0x00, sizeof(chunk_hash_t));
	memcpy(api->hash, asn->md5.buf, MIN((int)sizeof(chunk_hash_t), asn->md5.size));
	asn_INTEGER_to_uint32(&(asn->position), &(api->position));
	asn_INTEGER_to_int64(&(asn->size), &(api->size));
	asn_INTEGER_to_uint32(&(asn->nb), &(api->nb));
	return TRUE;
}

static gboolean
chunk_info_API2ASN(const chunk_info_t * api, ChunkInfo_t * asn)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);
	OCTET_STRING_fromBuf(&(asn->id.id), (const char*)api->id.id, sizeof(api->id.id));
	addr_info_API2ASN(&(api->id.addr), &(asn->id.addr));
	OCTET_STRING_fromBuf(&(asn->id.vol), api->id.vol, strlen_len(api->id.vol, sizeof(api->id.vol)));
	asn_uint32_to_INTEGER(&(asn->position), api->position);
	asn_int64_to_INTEGER(&(asn->size), api->size);
	asn_uint32_to_INTEGER(&(asn->nb), api->nb);
	OCTET_STRING_fromBuf(&(asn->md5), (const char*)api->hash, sizeof(chunk_hash_t));
	return TRUE;
}

static void
chunk_info_cleanASN(ChunkInfo_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_ChunkInfo, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_ChunkInfo, asn);
}

static struct abstract_sequence_handler_s descr_ChunkInfo =
{
	sizeof(ChunkInfo_t),
	sizeof(chunk_info_t),
	&asn_DEF_ChunkInfoSequence,
	(abstract_converter_f) chunk_info_ASN2API,
	(abstract_converter_f) chunk_info_API2ASN,
	(abstract_asn_cleaner_f) chunk_info_cleanASN,
	(abstract_api_cleaner_f) g_free,
	"chunk_info"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_ChunkInfo, chunk_info_marshall_gba);
DEFINE_SEQUENCE_UNMARSHALLER(&descr_ChunkInfo, chunk_info_unmarshall);
DEFINE_BODY_MANAGER(chunk_info_concat, chunk_info_unmarshall);

/* -------------------------------------------------------------------------- */

static gboolean
meta0_info_ASN2API(const Meta0Info_t * asn, meta0_info_t * api)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);
	memset(api, 0x00, sizeof(meta0_info_t));
	api->prefixes_size = asn->prefix.size;
	api->prefixes = g_malloc(api->prefixes_size);
	memcpy(api->prefixes, asn->prefix.buf, asn->prefix.size);
	addr_info_ASN2API(&(asn->addr), &(api->addr));
	return TRUE;
}

static gboolean
meta0_info_API2ASN(const meta0_info_t * api, Meta0Info_t * asn)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);
	memset(asn, 0x00, sizeof(Meta0Info_t));
	OCTET_STRING_fromBuf(&(asn->prefix), (char *) api->prefixes, api->prefixes_size);
	addr_info_API2ASN(&(api->addr), &(asn->addr));
	return TRUE;
}

static void
meta0_info_cleanASN(Meta0Info_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Meta0Info, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_Meta0Info, asn);
}

static const struct abstract_sequence_handler_s descr_Meta0Info =
{
	sizeof(Meta0Info_t),
	sizeof(meta0_info_t),
	&asn_DEF_Meta0InfoSequence,
	(abstract_converter_f) meta0_info_ASN2API,
	(abstract_converter_f) meta0_info_API2ASN,
	(abstract_asn_cleaner_f) meta0_info_cleanASN,
	(abstract_api_cleaner_f) meta0_info_clean,
	"meta0_info"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_Meta0Info, meta0_info_marshall_gba)
DEFINE_SEQUENCE_UNMARSHALLER(&descr_Meta0Info, meta0_info_unmarshall)

/* -------------------------------------------------------------------------- */

GByteArray *
strings_marshall_gba(GSList * list, GError ** err)
{
	ContentList_t list_asn;
	asn_enc_rval_t encRet;
	GByteArray *result = NULL;

	int write_f(const void *b, gsize bSize, void *key) {
		(void) key;
		g_byte_array_append(result, b, bSize);
		return 0;
	}

	memset(&list_asn, 0x00, sizeof(list_asn));

	result = g_byte_array_sized_new(4096);
	if (!result) {
		GSETERROR(err, "Failed to alloc byte array");
		return NULL;
	}

	for (GSList *l = list; l; l=l->next) {
		char *s = l->data;
		if (!s)
			continue;
		OCTET_STRING_t *os = OCTET_STRING_new_fromBuf(&asn_DEF_PrintableString, s, strlen(s));
		if (!os)
			continue;
		asn_set_add(&(list_asn.list), os);
	}

	encRet = der_encode(&asn_DEF_ContentList, &list_asn, write_f, 0);
	if (encRet.encoded == -1)
		goto error_encode;

	list_asn.list.free = free_OCTET_STRING;
	ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_ContentList, &list_asn);
	return result;

error_encode:
	GSETERROR(err, "Failed to encode arrays");
	return NULL;
}

gint
strings_unmarshall(GSList ** l, const void *buf, gsize len, GError ** err)
{
	if (!l || !buf || !len) {
		GSETERROR(err, "Invalid parameter (l=%p buf=%p len=%"G_GSIZE_FORMAT")", l, buf, len);
		return 0;
	}

	ContentList_t *asn = NULL;

	asn_codec_ctx_t codecCtx;
	codecCtx.max_stack_size = ASN1C_MAX_STACK;
	asn_dec_rval_t decRet = ber_decode(&codecCtx, &asn_DEF_ContentList, (void**)&asn, buf, len);
	switch (decRet.code) {
		case RC_OK:
			break;
		case RC_FAIL:
			GSETERROR(err, "Cannot deserialize: %s", "invalid content");
			return 0;
		case RC_WMORE:
			GSETERROR(err, "Cannot deserialize: %s", "uncomplete content");
			return 0;
	}

	GSList *result = NULL;
	for (int i=0; i<asn->list.count ;i++) {
		OCTET_STRING_t *s = asn->list.array[i];
		if (!s)
			continue;
		result = g_slist_prepend(result, g_strndup((gchar*)s->buf, s->size));
	}
	*l = result;

	asn->list.free = free_OCTET_STRING;
	ASN_STRUCT_FREE(asn_DEF_ContentList, asn);
	return 1;
}

/* ------------------------------------------------------------------------- */

static void
meta2_property_cleanASN(Meta2Property_t *asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Meta2Property, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_Meta2Property, asn);
}

static void
free_Meta2Property(Meta2Property_t * prop)
{
	meta2_property_cleanASN(prop, FALSE);
}

static gboolean
meta2_property_ASN2API(const Meta2Property_t *asn, meta2_property_t *api)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (asn->name.buf && asn->name.size);

	memset(api, 0, sizeof(*api));
	api->name = g_strndup((gchar*)asn->name.buf, asn->name.size);
	asn_INTEGER_to_int64(&(asn->version), &(api->version));
	api->value = g_byte_array_new();
	if (asn->value.size > 0 && asn->value.buf != NULL)
		g_byte_array_append(api->value, asn->value.buf, asn->value.size);
	return TRUE;
}

static gboolean
meta2_property_API2ASN(const meta2_property_t *api, Meta2Property_t *asn)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	memset(asn, 0, sizeof(*asn));
	if (api->name)
		OCTET_STRING_fromBuf(&(asn->name), api->name, strlen(api->name));
	asn_int64_to_INTEGER(&(asn->version), api->version);
	if (api->value && api->value->data && api->value->len)
		OCTET_STRING_fromBuf(&(asn->value), (gchar*)api->value->data, api->value->len);
	else
		OCTET_STRING_fromBuf(&(asn->value), "", 0);
	return TRUE;
}

static struct abstract_sequence_handler_s descr_Meta2Property =
{
	sizeof(Meta2Property_t),
	sizeof(meta2_property_t),
	&asn_DEF_Meta2PropertySequence,
	(abstract_converter_f) meta2_property_ASN2API,
	(abstract_converter_f) meta2_property_API2ASN,
	(abstract_asn_cleaner_f) meta2_property_cleanASN,
	(abstract_api_cleaner_f) meta2_property_clean,
	"meta2_property"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_Meta2Property, meta2_property_marshall_gba);
DEFINE_SEQUENCE_UNMARSHALLER(&descr_Meta2Property, meta2_property_unmarshall);

static gboolean
meta2_raw_chunk_API2ASN(const struct meta2_raw_chunk_s * src, Meta2RawChunk_t * dst)
{
	EXTRA_ASSERT (src != NULL);
	EXTRA_ASSERT (dst != NULL);

	memset(dst, 0, sizeof(*dst));
	chunk_id_API2ASN(&(src->id), &(dst->id));
	asn_uint32_to_INTEGER(&(dst->position), src->position);
	asn_int64_to_INTEGER(&(dst->size), src->size);
	OCTET_STRING_fromBuf(&(dst->flags), (char *) (&(src->flags)), sizeof(src->flags));
	OCTET_STRING_fromBuf(&(dst->hash), (char *) (&(src->hash)), sizeof(src->hash));

	if (src->metadata && src->metadata->data && src->metadata->len > 0)
		dst->metadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
				(const char*)src->metadata->data, src->metadata->len);
	return TRUE;
}

static gboolean
meta2_raw_chunk_ASN2API(const Meta2RawChunk_t * src, struct meta2_raw_chunk_s * dst)
{
	EXTRA_ASSERT (src != NULL);
	EXTRA_ASSERT (dst != NULL);

	memset(dst, 0, sizeof(*dst));
	chunk_id_ASN2API(&(src->id), &(dst->id));
	asn_INTEGER_to_uint32(&(src->position), &(dst->position));
	asn_INTEGER_to_int64(&(src->size), &(dst->size));
	g_memmove(&(dst->flags), src->flags.buf, src->flags.size);
	g_memmove(&(dst->hash), src->hash.buf, src->hash.size);
	if (src->metadata && src->metadata->buf && src->metadata->size > 0)
		dst->metadata = g_byte_array_append(g_byte_array_new(), src->metadata->buf, src->metadata->size);
	return TRUE;
}

static void
meta2_raw_chunk_cleanASN(Meta2RawChunk_t *asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Meta2RawChunk, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_Meta2RawChunk, asn);
}

static void
free_Meta2RawChunk(Meta2RawChunk_t * chunk)
{
	meta2_raw_chunk_cleanASN(chunk, FALSE);
}

static gboolean
meta2_raw_content_header_ASN2API(const Meta2RawContentHeader_t *asn,
		meta2_raw_content_header_t *api)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);

	memset(api, 0, sizeof(*api));
	asn_INTEGER_to_uint32(&(asn->nbChunks), &(api->nb_chunks));
	asn_INTEGER_to_int64(&(asn->size), &(api->size));
	g_memmove(api->path, asn->path.buf, asn->path.size);
	g_memmove(&(api->flags), asn->flags.buf, asn->flags.size);
	g_memmove(api->container_id, asn->cID.buf, asn->cID.size);

	if (asn->metadata) {
		api->metadata = g_byte_array_sized_new(asn->metadata->size);
		g_byte_array_append(api->metadata, asn->metadata->buf, asn->metadata->size);
	}
	if (asn->systemMetadata) {
		api->system_metadata = g_byte_array_sized_new(asn->systemMetadata->size);
		g_byte_array_append(api->system_metadata, asn->systemMetadata->buf, asn->systemMetadata->size);
	}
	return TRUE;
}

static gboolean
meta2_raw_content_header_API2ASN(const meta2_raw_content_header_t *api,
	Meta2RawContentHeader_t *asn)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);

	memset(asn, 0, sizeof(*asn));
	OCTET_STRING_fromBuf( &(asn->path), api->path, strlen(api->path));
	OCTET_STRING_fromBuf( &(asn->cID), (char *) api->container_id, sizeof(container_id_t));
	OCTET_STRING_fromBuf( &(asn->flags), (char *) &(api->flags), sizeof(api->flags));
	asn_int64_to_INTEGER( &(asn->size), api->size);
	asn_uint32_to_INTEGER(&(asn->nbChunks), api->nb_chunks);

	if (api->metadata && api->metadata->len > 0 && api->metadata->data)
		asn->metadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
		    (const char*)api->metadata->data, api->metadata->len);
	if (api->system_metadata && api->system_metadata->len > 0 && api->system_metadata->data)
		asn->systemMetadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
		    (const char*)api->system_metadata->data, api->system_metadata->len);
	return TRUE;
}

static gboolean
meta2_raw_content_v2_ASN2API(const Meta2RawContentV2_t *asn, meta2_raw_content_v2_t *api)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);

	memset(api, 0, sizeof(*api));
	meta2_raw_content_header_ASN2API(&(asn->header), &(api->header));

	for (int i = asn->chunks.list.count - 1; i >= 0; i--) {
		Meta2RawChunk_t *c_asn = NULL;
		if (!(c_asn = asn->chunks.list.array[i])) /* Skip NULL's */
			continue;
		struct meta2_raw_chunk_s *c_api = g_malloc0(sizeof(*c_api));
		meta2_raw_chunk_ASN2API(c_asn, c_api);
		api->raw_chunks = g_slist_prepend(api->raw_chunks, c_api);
	}

	for (int i = asn->services.list.count - 1; i >= 0; i--) {
		ServiceInfo_t *c_asn = NULL;
		if (!(c_asn = asn->services.list.array[i])) /* Skip NULL's */
			continue;
		service_info_t *c_api = g_malloc0(sizeof(*c_api));
		service_info_ASN2API(c_asn, c_api);
		api->raw_services = g_slist_prepend(api->raw_services, c_api);
	}

	for (int i = asn->properties.list.count - 1; i >= 0; i--) {
		Meta2Property_t *c_asn = NULL;
		if (!(c_asn = asn->properties.list.array[i])) /* Skip NULL's */
			continue;
		meta2_property_t *c_api = g_malloc0(sizeof(*c_api));
		meta2_property_ASN2API(c_asn, c_api);
		api->properties = g_slist_prepend(api->properties, c_api);
	}

	return TRUE;
}

static gboolean
meta2_raw_content_v2_API2ASN(const meta2_raw_content_v2_t *api, Meta2RawContentV2_t *asn)
{
	EXTRA_ASSERT (asn != NULL);
	EXTRA_ASSERT (api != NULL);

	memset(asn, 0, sizeof(*asn));
	meta2_raw_content_header_API2ASN(&(api->header), &(asn->header));

	for (GSList *l=api->raw_chunks; l ;l=l->next) {
		struct meta2_raw_chunk_s *chunk_api;
		if (!(chunk_api = l->data))
			continue;
		Meta2RawChunk_t *chunk_asn = calloc(1, sizeof(Meta2RawChunk_t));
		meta2_raw_chunk_API2ASN(chunk_api, chunk_asn);
		asn_set_add(&(asn->chunks.list), chunk_asn);
	}

	for (GSList *l=api->raw_services; l ;l=l->next) {
		service_info_t *si;
		if (!(si = l->data))
			continue;
		ServiceInfo_t *si_asn = calloc(1, sizeof(*si_asn));
		service_info_API2ASN(si, si_asn);
		asn_set_add(&(asn->services.list), si_asn);
	}

	for (GSList *l=api->properties; l ;l=l->next) {
		meta2_property_t *prop_api;
		if (!(prop_api = l->data))
			continue;
		Meta2Property_t *prop_asn = calloc(1, sizeof(*prop_asn));
		meta2_property_API2ASN(prop_api, prop_asn);
		asn_set_add(&(asn->properties.list), prop_asn);
	}

	return TRUE;
}

static void
meta2_raw_content_v2_cleanASN(Meta2RawContentV2_t *asn, gboolean only_content)
{
	if (!asn)
		return;
	asn->chunks.list.free = free_Meta2RawChunk;
	asn->services.list.free = free_ServiceInfo;
	asn->properties.list.free = free_Meta2Property;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Meta2RawContentV2, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_Meta2RawContentV2, asn);
}

static void
meta2_raw_content_cleanASN(Meta2RawContent_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	asn->chunks.list.free = free_Meta2RawChunk;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Meta2RawContent, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_Meta2RawContent, asn);
}

static gboolean
meta2_raw_content_ASN2API(const Meta2RawContent_t * src, struct meta2_raw_content_s *dst)
{
	EXTRA_ASSERT (src != NULL);
	EXTRA_ASSERT (dst != NULL);

	memset(dst, 0, sizeof(*dst));
	asn_INTEGER_to_uint32(&(src->header.nbChunks), &(dst->nb_chunks));
	asn_INTEGER_to_int64(&(src->header.size), &(dst->size));
	/* asn_INTEGER_to_int64(&(src->header.version), &(dst->version)); */
	if(NULL != src->header.version)
		asn_INTEGER_to_int64(src->header.version, &(dst->version));
	g_memmove(dst->path, src->header.path.buf, src->header.path.size);
	g_memmove(&(dst->flags), src->header.flags.buf, src->header.flags.size);
	g_memmove(dst->container_id, src->header.cID.buf, src->header.cID.size);

	if (src->header.metadata) {
		dst->metadata = g_byte_array_sized_new(src->header.metadata->size);
		g_byte_array_append(dst->metadata, src->header.metadata->buf, src->header.metadata->size);
	}

	if (src->header.systemMetadata) {
		dst->system_metadata = g_byte_array_sized_new(src->header.systemMetadata->size);
		g_byte_array_append(dst->system_metadata, src->header.systemMetadata->buf, src->header.systemMetadata->size);
	}

	for (int i = src->chunks.list.count - 1; i >= 0; i--) {
		Meta2RawChunk_t *chunk_asn  = src->chunks.list.array[i];
		if (!chunk_asn)
			continue;
		struct meta2_raw_chunk_s *chunk_api = g_malloc0(sizeof(struct meta2_raw_chunk_s));
		meta2_raw_chunk_ASN2API(chunk_asn, chunk_api);
		dst->raw_chunks = g_slist_prepend(dst->raw_chunks, chunk_api);
	}

	return TRUE;
}

static gboolean
meta2_raw_content_API2ASN(const struct meta2_raw_content_s * src, Meta2RawContent_t * dst)
{
	EXTRA_ASSERT (src != NULL);
	EXTRA_ASSERT (dst != NULL);

	memset(dst, 0, sizeof(*dst));
	OCTET_STRING_fromBuf(&(dst->header.path), src->path, strlen(src->path));
	OCTET_STRING_fromBuf(&(dst->header.cID), (char *) src->container_id, sizeof(container_id_t));
	OCTET_STRING_fromBuf(&(dst->header.flags), (char *) &(src->flags), sizeof(src->flags));
	asn_int64_to_INTEGER(&(dst->header.size), src->size);
	asn_uint32_to_INTEGER(&(dst->header.nbChunks), src->nb_chunks);

	if (src->version > 0) {
		dst->header.version = calloc(1,sizeof(INTEGER_t));
		asn_int64_to_INTEGER(dst->header.version, src->version);
	}

	if (src->metadata && src->metadata->len > 0 && src->metadata->data) {
		dst->header.metadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
				(const char*)src->metadata->data, src->metadata->len);
		if (!dst->header.metadata)
			return FALSE;
	}

	if (src->system_metadata && src->system_metadata->len > 0 && src->system_metadata->data) {
		dst->header.systemMetadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
				(const char*)src->system_metadata->data, src->system_metadata->len);
		if (!dst->header.systemMetadata)
			return FALSE;
	}

	for (GSList *c = src->raw_chunks; c; c = g_slist_next(c)) {
		if (!c->data) /* skip NULL chunks */
			continue;
		Meta2RawChunk_t *chunk_asn = calloc(1,sizeof(Meta2RawChunk_t));
		struct meta2_raw_chunk_s *chunk_api = (struct meta2_raw_chunk_s *) c->data;
		meta2_raw_chunk_API2ASN(chunk_api, chunk_asn);
		asn_set_add(&(dst->chunks.list), chunk_asn);
	}

	return TRUE;
}

GByteArray *
meta2_maintenance_marshall_content(struct meta2_raw_content_s * content, GError ** err)
{
	asn_enc_rval_t encRet;
	GByteArray *result = NULL;
	Meta2RawContent_t asn1_content;

	int write_f(const void *b, gsize bSize, void *key)
	{
		(void) key;

		GByteArray *a = g_byte_array_append(result, b, bSize);

		return a ? 0 : -1;
	}

	/*sanity checks */
	if (!content) {
		GSETERROR(err, "Invalid parameter");
		goto error_params;
	}

	/*prepare the structures */
	memset(&asn1_content, 0x00, sizeof(Meta2RawContent_t));
	if (!(result = g_byte_array_sized_new(4096))) {
		GSETERROR(err, "memory allocation failure");
		goto error_byte_array;
	}

	/*fills an ASN.1 structure */
	if (!meta2_raw_content_API2ASN(content, &asn1_content)) {
		GSETERROR(err, "API to ASN.1 mapping error");
		goto error_mapping;
	}

	/*serialize the ASN.1 structure */
	encRet = der_encode(&asn_DEF_Meta2RawContent, &asn1_content, write_f, 0);
	if (encRet.encoded == -1) {
		GSETERROR(err, "ASN.1 encoding error");
		goto error_encode;
	}

	/*free the ASN.1 structure */
	meta2_raw_content_cleanASN(&asn1_content, TRUE);
	return result;

      error_mapping:
      error_encode:
	g_byte_array_free(result, 1);
      error_byte_array:
	meta2_raw_content_cleanASN(&asn1_content, TRUE);
      error_params:
	return NULL;
}

struct meta2_raw_content_s *
meta2_maintenance_content_unmarshall_buffer(guint8 * buf, gsize buf_size, GError ** err)
{
	asn_dec_rval_t decRet;
	asn_codec_ctx_t codecCtx;
	struct meta2_raw_content_s *result = NULL;
	Meta2RawContent_t *asn1_content = NULL;

	/*sanity checks */
	if (!buf || buf_size <= 0)
		goto error_params;

	/*prepare the working structures */
	result = g_try_malloc0(sizeof(struct meta2_raw_content_s));
	if (!result)
		goto error_content;

	/*deserialize the encoded form */
	codecCtx.max_stack_size = 0;
	decRet = ber_decode(&codecCtx, &asn_DEF_Meta2RawContent, (void *) &asn1_content, buf, buf_size);
	switch (decRet.code) {
	case RC_OK:
		break;
	case RC_FAIL:
		GSETERROR(err, "Cannot deserialize: %s", "invalid content");
		goto error_decode;
	case RC_WMORE:
		GSETERROR(err, "Cannot deserialize: %s", "uncomplete content");
		goto error_decode;
	}

	/*map the ASN.1 in a common structure */
	if (!meta2_raw_content_ASN2API(asn1_content, result)) {
		GSETERROR(err, "ASN.1 to API mapping failure");
		goto error_mapping;
	}

	/*clean the working structures and return the success */
	meta2_raw_content_cleanASN(asn1_content, FALSE);
	return result;

      error_mapping:
      error_decode:
	meta2_raw_content_cleanASN(asn1_content, FALSE);
      error_content:
      error_params:
	return NULL;
}

static struct abstract_sequence_handler_s descr_Meta2RawContent =
{
	sizeof(Meta2RawContentV2_t),
	sizeof(meta2_raw_content_v2_t),
	&asn_DEF_Meta2RawContentV2Sequence,
	(abstract_converter_f) meta2_raw_content_v2_ASN2API,
	(abstract_converter_f) meta2_raw_content_v2_API2ASN,
	(abstract_asn_cleaner_f) meta2_raw_content_v2_cleanASN,
	(abstract_api_cleaner_f) meta2_raw_content_v2_clean,
	"meta2_raw_content_v2"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_Meta2RawContent, meta2_raw_content_v2_marshall_gba);
DEFINE_SEQUENCE_UNMARSHALLER(&descr_Meta2RawContent, meta2_raw_content_v2_unmarshall);

/* NSINFO ------------------------------------------------------------------- */

static gboolean
list_conversion (const struct NamespaceInfoValueList *nsinfo_vlist,
		GHashTable **ht, GHashTable* (*conv_func)(GSList * pairs, GError ** err))
{
	EXTRA_ASSERT (nsinfo_vlist != NULL);
	EXTRA_ASSERT (ht != NULL);

	void _free(GSList *valuelist) {
		if (valuelist) {
			g_slist_foreach(valuelist, key_value_pair_gclean, NULL);
			g_slist_free(valuelist);
		}
	}

	if (nsinfo_vlist->list.count <= 0) {
		*ht = key_value_pairs_empty();
	} else {
		GSList* valuelist = NULL;
		GError *error = NULL;

		for (int i = 0; i < nsinfo_vlist->list.count; i++) {
			Parameter_t* asn_prop;
			if (!(asn_prop = nsinfo_vlist->list.array[i]))
				continue;
			key_value_pair_t* api_prop = g_malloc0(sizeof(key_value_pair_t));
			key_value_pair_ASN2API(asn_prop, api_prop);
			valuelist = g_slist_prepend(valuelist, api_prop);
		}

		*ht = (conv_func(valuelist, &error));
		g_slist_foreach(valuelist, key_value_pair_gclean, NULL);
		g_slist_free(valuelist);
		valuelist = NULL;

		if (*ht == NULL) {
			ERROR("Failed to convert key_value_pairs to map in namespace_info ASN to API conversion : %s",
					gerror_get_message(error));
			g_clear_error(&error);
			return FALSE;
		}
	}

	return TRUE;
}

static gboolean
namespace_info_ASN2API(const NamespaceInfo_t *asn, namespace_info_t *api)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	memset(api, 0, sizeof(*api));
	memcpy(api->name, asn->name.buf, MIN((int)sizeof(api->name), asn->name.size));
	addr_info_ASN2API(&(asn->addr), &(api->addr));
	asn_INTEGER_to_int64(&(asn->chunkSize), &(api->chunk_size));

	if (!list_conversion(&(asn->options), &(api->options), key_value_pairs_convert_to_map))
		return FALSE;

	if (!list_conversion(&(asn->storagePolicy), &(api->storage_policy), key_value_pairs_convert_to_map))
		return FALSE;

	if (!list_conversion(&(asn->dataSecurity), &(api->data_security), key_value_pairs_convert_to_map))
		return FALSE;

	if (!list_conversion(&(asn->dataTreatments), &(api->data_treatments), key_value_pairs_convert_to_map))
		return FALSE;

	if (!list_conversion(&(asn->storageClass), &(api->storage_class), key_value_pairs_convert_to_map))
		return FALSE;

	return TRUE;

}

static gboolean
hashtable_conversion(GHashTable *ht,
		struct NamespaceInfoValueList *nsinfo_vlist,
		GSList* (*conv_func)(GHashTable *, gboolean, GError **))
{
	EXTRA_ASSERT (ht != NULL);
	EXTRA_ASSERT (nsinfo_vlist != NULL);
	EXTRA_ASSERT (conv_func != NULL);

	GError *error = NULL;
	GSList* result = conv_func(ht, TRUE, &error);
	if (result == NULL && error != NULL) {
		ERROR("Failed to convert map to key_value_pairs in namespace_info API to ASN conversion : %s",
				gerror_get_message(error));
		g_clear_error(&error);
		return FALSE;
	}

	if (result != NULL) {
		/* fill the array */
		for (GSList *p = result; p != NULL; p = p->next) {
			key_value_pair_t* api_prop;
			if (!(api_prop = (key_value_pair_t*)p->data))
				continue;
			Parameter_t* asn_prop = calloc(1, sizeof(Parameter_t));
			key_value_pair_API2ASN(api_prop, asn_prop);
			asn_set_add(&(nsinfo_vlist->list), asn_prop);
		}

		/* free the temp list */
		g_slist_foreach(result, key_value_pair_gclean, NULL);
		g_slist_free(result);
	}

	return TRUE;
}

static gboolean
namespace_info_API2ASN(const namespace_info_t * api, NamespaceInfo_t * asn)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	OCTET_STRING_fromBuf(&(asn->name), api->name, strlen(api->name));
	addr_info_API2ASN(&(api->addr), &(asn->addr));
	asn_int64_to_INTEGER(&(asn->chunkSize), api->chunk_size);

	if (!hashtable_conversion(api->options, &(asn->options), key_value_pairs_convert_from_map))
		return FALSE;

	if(!hashtable_conversion(api->storage_policy, &(asn->storagePolicy), key_value_pairs_convert_from_map))
		return FALSE;

	if(!hashtable_conversion(api->data_security, &(asn->dataSecurity), key_value_pairs_convert_from_map))
		return FALSE;

	if(!hashtable_conversion(api->data_treatments, &(asn->dataTreatments), key_value_pairs_convert_from_map))
		return FALSE;

	if(!hashtable_conversion(api->storage_class, &(asn->storageClass), key_value_pairs_convert_from_map))
		return FALSE;

	return TRUE;
}

static void
namespace_info_cleanASN(NamespaceInfo_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	asn->options.list.free = free_Parameter;
	asn->storagePolicy.list.free = free_Parameter;
	asn->dataSecurity.list.free = free_Parameter;
	asn->dataTreatments.list.free = free_Parameter;
	asn->storageClass.list.free = free_Parameter;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_NamespaceInfo, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_NamespaceInfo, asn);
}

GByteArray *
namespace_info_marshall(namespace_info_t * namespace_info, GError ** err)
{
	asn_enc_rval_t encRet;
	GByteArray *result = NULL;
	NamespaceInfo_t asn1_namespace_info;

	/*sanity checks */
	if (!namespace_info) {
		GSETERROR(err, "Invalid parameter");
		goto error_params;
	}

	memset(&asn1_namespace_info, 0x00, sizeof(NamespaceInfo_t));

	/*fills an ASN.1 structure */
	if (!namespace_info_API2ASN(namespace_info, &asn1_namespace_info)) {
		GSETERROR(err, "API to ASN.1 mapping error");
		goto error_mapping;
	}

	/*serialize the ASN.1 structure */
	if (!(result = g_byte_array_sized_new(4096))) {
		GSETERROR(err, "memory allocation failure");
		goto error_alloc_gba;
	}
	encRet = der_encode(&asn_DEF_NamespaceInfo, &asn1_namespace_info, write_in_gba, result);
	if (encRet.encoded == -1) {
		GSETERROR(err, "ASN.1 encoding error");
		goto error_encode;
	}

	/*free the ASN.1 structure */
	namespace_info_cleanASN(&asn1_namespace_info, TRUE);

	return result;

error_encode:
	g_byte_array_free(result, TRUE);
error_alloc_gba:
error_mapping:
	namespace_info_cleanASN(&asn1_namespace_info, TRUE);
error_params:

	return NULL;
}

namespace_info_t *
namespace_info_unmarshall(const guint8 * buf, gsize buf_len, GError ** err)
{
	asn_dec_rval_t decRet;
	asn_codec_ctx_t codecCtx;
	namespace_info_t *result = NULL;
	NamespaceInfo_t *asn1_namespace_info = NULL;

	/*sanity checks */
	if (!buf) {
		GSETCODE(err, ERRCODE_PARAM, "Invalid paremeter");
		return NULL;
	}

	/*deserialize the encoded form */
	codecCtx.max_stack_size = ASN1C_MAX_STACK;
	decRet = ber_decode(&codecCtx, &asn_DEF_NamespaceInfo, (void *) &asn1_namespace_info, buf, buf_len);
	if (decRet.code != RC_OK) {
		GSETCODE(err, CODE_INTERNAL_ERROR, "%s", (decRet.code == RC_WMORE) ? "uncomplete data" : "invalid data");
		namespace_info_cleanASN(asn1_namespace_info, FALSE);
		return NULL;
	}

	/*prepare the working structures */
	result = g_malloc0(sizeof(namespace_info_t));

	/*map the ASN.1 in a common structure */
	int rc = namespace_info_ASN2API(asn1_namespace_info, result);
	namespace_info_cleanASN(asn1_namespace_info, FALSE);
	asn1_namespace_info = NULL;
	if (rc)
		return result;

	namespace_info_free(result);
	result = NULL;

	GSETCODE(err, CODE_INTERNAL_ERROR, "ASN.1 to API mapping failure");
	return NULL;
}

/* -------------------------------------------------------------------------- */

static gboolean
path_info_ASN2API(const PathInfo_t * asn, path_info_t * api)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	memset(api->path, 0, sizeof(api->path));
	memcpy(api->path, asn->path.buf, MIN((int)sizeof(api->path), asn->path.size));
	api->size = 0;
	if (asn->size) {
		asn_INTEGER_to_int64(asn->size, &(api->size));
		api->hasSize = TRUE;
	} else {
		api->hasSize = FALSE;
	}

	if (asn->userMetadata && asn->userMetadata->buf && asn->userMetadata->size > 0) {
		api->user_metadata = g_byte_array_sized_new(asn->userMetadata->size);
		g_byte_array_append(api->user_metadata, asn->userMetadata->buf, asn->userMetadata->size);
	}

	if (asn->systemMetadata && asn->systemMetadata->buf && asn->systemMetadata->size > 0) {
		api->system_metadata = g_byte_array_sized_new(asn->systemMetadata->size);
		g_byte_array_append(api->system_metadata, asn->systemMetadata->buf, asn->systemMetadata->size);
	}

	return TRUE;
}

static gboolean
path_info_API2ASN(const path_info_t * api, PathInfo_t * asn)
{
	EXTRA_ASSERT (api != NULL);
	EXTRA_ASSERT (asn != NULL);

	OCTET_STRING_fromBuf(&(asn->path), api->path, strlen_len(api->path, sizeof(api->path)));
	if (api->hasSize) {
		asn->size = calloc(1, sizeof(INTEGER_t));
		asn_int64_to_INTEGER(asn->size, api->size);
	}
	if (api->user_metadata && api->user_metadata->data && api->user_metadata->len > 0) {
		asn->userMetadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
				(const char*)api->user_metadata->data, api->user_metadata->len);
	}
	if (api->system_metadata && api->system_metadata->data && api->system_metadata->len > 0) {
		asn->systemMetadata = OCTET_STRING_new_fromBuf(&asn_DEF_OCTET_STRING,
				(const char*)api->system_metadata->data, api->system_metadata->len);
	}
	return TRUE;
}

static void
path_info_cleanASN(PathInfo_t * asn, gboolean only_content)
{
	if (!asn)
		return;
	if (only_content)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_PathInfo, asn);
	else
		ASN_STRUCT_FREE(asn_DEF_PathInfo, asn);
}

static struct abstract_sequence_handler_s descr_PathInfo =
{
	sizeof(PathInfo_t),
	sizeof(path_info_t),
	&asn_DEF_PathInfoSequence,
	(abstract_converter_f) path_info_ASN2API,
	(abstract_converter_f) path_info_API2ASN,
	(abstract_asn_cleaner_f) path_info_cleanASN,
	(abstract_api_cleaner_f) g_free,
	"path_info"
};

DEFINE_SEQUENCE_MARSHALLER_GBA(&descr_PathInfo, path_info_marshall_gba);
DEFINE_SEQUENCE_UNMARSHALLER(&descr_PathInfo, path_info_unmarshall);
DEFINE_BODY_MANAGER(path_info_concat, path_info_unmarshall);

/* -------------------------------------------------------------------------- */

static void
free_asn1_container(Meta1RawContainer_t * asn1_container, gboolean content_only)
{
	if (!asn1_container)
		return;
	asn1_container->meta2.list.free = free_AddrInfo;
	if (content_only)
		ASN_STRUCT_FREE_CONTENTS_ONLY(asn_DEF_Meta1RawContainer, asn1_container);
	else
		ASN_STRUCT_FREE(asn_DEF_Meta1RawContainer, asn1_container);
}

static gboolean
container_asn1_to_api(Meta1RawContainer_t * src, struct meta1_raw_container_s *dst)
{
	int i;

	if (!src || !dst)
		return FALSE;

	memset(dst, 0x00, sizeof(struct meta1_raw_container_s));

	/*map the fields */
	g_memmove(dst->id, src->id.buf, src->id.size);
	g_memmove(dst->name, src->name.buf, src->name.size);
	g_memmove(&(dst->flags), src->flags.buf, src->flags.size);

	/* map meta2 addr list */
	for (i = src->meta2.list.count - 1; i >= 0; i--) {
		addr_info_t *addr_api = NULL;
		AddrInfo_t *addr_asn;

		addr_asn = src->meta2.list.array[i];
		if (!addr_asn) {
			WARN("NULL ASN.1 addr");
			continue;
		}

		addr_api = g_malloc0(sizeof(addr_info_t));

		if (!addr_info_ASN2API(addr_asn, addr_api)) {
			WARN("ASN.1 to ASN.1 mapping failure");
			g_free(addr_api);
			continue;
		}

		dst->meta2 = g_slist_prepend(dst->meta2, addr_api);
	}

	return TRUE;
}

static gboolean
container_api_to_asn1(struct meta1_raw_container_s *src, Meta1RawContainer_t * dst)
{
	GSList *meta2;

	if (!src || !dst)
		return FALSE;

	memset(dst, 0x00, sizeof(Meta1RawContainer_t));

	/* map simple fields */
	OCTET_STRING_fromBuf(&(dst->id), (char *) src->id, sizeof(container_id_t));
	OCTET_STRING_fromBuf(&(dst->name), src->name, strnlen(src->name, sizeof(src->name)));
	OCTET_STRING_fromBuf(&(dst->flags), (char *) &(src->flags), sizeof(src->flags));

	/* map meta2 addr list */
	for (meta2 = src->meta2; meta2; meta2 = meta2->next) {
		AddrInfo_t *addr_asn;
		addr_info_t *addr_api;

		if (!meta2->data) {
			WARN("NULL ASN.1 chunk");
			continue;
		}
		else
			addr_api = (addr_info_t *) (meta2->data);

		addr_asn = calloc(1, sizeof(AddrInfo_t));

		if (!addr_info_API2ASN(addr_api, addr_asn)) {
			WARN("API to ASN.1 mapping failure");
			free(addr_asn);
			continue;
		}

		asn_set_add(&(dst->meta2.list), addr_asn);
	}

	return TRUE;
}

GByteArray *
meta1_raw_container_marshall(struct meta1_raw_container_s * container, GError ** err)
{
	asn_enc_rval_t encRet;
	GByteArray *result = NULL;
	Meta1RawContainer_t asn1_container;

	/*sanity checks */
	if (!container) {
		GSETERROR(err, "Invalid parameter");
		goto error_params;
	}

	memset(&asn1_container, 0x00, sizeof(Meta1RawContainer_t));

	/*fills an ASN.1 structure */
	if (!container_api_to_asn1(container, &asn1_container)) {
		GSETERROR(err, "API to ASN.1 mapping error");
		goto error_mapping;
	}

	/*serialize the ASN.1 structure */
	if (!(result = g_byte_array_sized_new(4096))) {
		GSETERROR(err, "memory allocation failure");
		goto error_alloc_gba;
	}
	encRet = der_encode(&asn_DEF_Meta1RawContainer, &asn1_container, write_in_gba, result);
	if (encRet.encoded == -1) {
		GSETERROR(err, "ASN.1 encoding error");
		goto error_encode;
	}

	/*free the ASN.1 structure */
	free_asn1_container(&asn1_container, TRUE);
	return result;

      error_encode:
	g_byte_array_free(result, TRUE);
      error_alloc_gba:
      error_mapping:
	free_asn1_container(&asn1_container, TRUE);
      error_params:
	return NULL;
}

struct meta1_raw_container_s *
meta1_raw_container_unmarshall(guint8 * buf, gsize buf_len, GError ** err)
{
	asn_dec_rval_t decRet;
	asn_codec_ctx_t codecCtx;
	struct meta1_raw_container_s *result = NULL;
	Meta1RawContainer_t *asn1_container = NULL;

	/*sanity checks */
	if (!buf)
		goto error_params;

	/*prepare the working structures */
	result = g_try_malloc0(sizeof(struct meta1_raw_container_s));
	if (!result)
		goto error_container;

	/*deserialize the encoded form */
	codecCtx.max_stack_size = ASN1C_MAX_STACK;
	decRet = ber_decode(&codecCtx, &asn_DEF_Meta1RawContainer, (void *) &asn1_container, buf, buf_len);
	switch (decRet.code) {
	case RC_OK:
		break;
	case RC_FAIL:
		GSETERROR(err, "Cannot deserialize: %s", "invalid container");
		goto error_decode;
	case RC_WMORE:
		GSETERROR(err, "Cannot deserialize: %s", "uncomplete container");
		goto error_decode;
	}

	/*map the ASN.1 in a common structure */
	if (!container_asn1_to_api(asn1_container, result)) {
		GSETERROR(err, "ASN.1 to API mapping failure");
		goto error_mapping;
	}

	/*clean the working structures and return the success */
	free_asn1_container(asn1_container, FALSE);
	return result;

      error_mapping:
      error_decode:
	free_asn1_container(asn1_container, FALSE);
      error_container:
      error_params:
	return NULL;
}

