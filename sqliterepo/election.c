/*
OpenIO SDS sqliterepo
Copyright (C) 2014 Worldine, original work as part of Redcurrant
Copyright (C) 2015 OpenIO, modified as part of OpenIO Software Defined Storage

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/

#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>

#include <metautils/lib/metautils.h>

#include "sqliterepo.h"
#include "hash.h"
#include "election.h"
#include "version.h"
#include "sqlx_remote.h"
#include "synchro.h"
#include "gridd_client_pool.h"
#include "internals.h"

#define EVENTLOG_SIZE 16
#define STATUS_FINAL(e) ((e) >= STEP_SLAVE)

typedef guint req_id_t;

enum election_step_e
{
	STEP_NONE = 0,
	STEP_CREATING,
	STEP_WATCHING,
	STEP_LISTING,
	STEP_LEAVING,
	STEP_LEAVING_FAILING,
	STEP_ASKING,
	STEP_CHECKING_MASTER,
	STEP_CHECKING_SLAVES,
	STEP_SYNCING,

	/* final */
	STEP_SLAVE,
	STEP_MASTER,
	STEP_FAILED,
#define STEP_MAX (STEP_FAILED+1)
};

enum event_type_e
{
	/* ping, a.k.a poke, etc */
	EVT_NONE = 0,

	/* interruptions */
	EVT_DISCONNECTED,
	EVT_LEAVE_REQ,
	EVT_SYNC_REQ,
	EVT_LEFT_SELF,
	EVT_LEFT_MASTER,

	/* actions results */
	EVT_GETVERS_OK,
	EVT_GETVERS_KO,
	EVT_GETVERS_OLD,
	EVT_GETVERS_RACE,

	EVT_MASTER_OK,
	EVT_MASTER_KO,
	EVT_MASTER_BAD,

	EVT_CREATE_OK,
	EVT_CREATE_KO,

	EVT_EXISTS_OK,
	EVT_EXISTS_KO,

	EVT_LIST_OK,
	EVT_LIST_KO,

	EVT_LEAVE_OK,
	EVT_LEAVE_KO,

	EVT_SYNC_OK,
	EVT_SYNC_KO,
};

/* @private */
struct logged_event_s
{
	enum event_type_e event   :8;
	enum election_step_e pre  :8;
	enum election_step_e post :8;
};

/* @private */
struct deque_beacon_s
{
	guint count;
	struct election_member_s *front;
	struct election_member_s *back;
};

/* @private */
struct election_manager_s
{
	struct election_manager_vtable_s *vtable;

	struct sqlx_peering_s *peering;
	struct sqlx_sync_s *sync;

	/* do not free or change the fields below */
	const struct replication_config_s *config;

	/* GTree<gchar*,GCond*> */
	GTree *conditions;

	/* GTree<gchar*,struct election_member_s*> */
	GTree *members_by_key;

	GMutex lock;

	struct deque_beacon_s members_by_state[STEP_MAX];

	/* how long we accept to wait for a status. */
	gint64 delay_wait;

	/* we DO NOT wait for an election in a transitional state since longer
	 * than that */
	gint64 delay_nowait_pending;

	/* how long we wait before expiring a base */
	gint64 delay_expire_NONE;
	gint64 delay_expire_SLAVE;
	gint64 delay_expire_MASTER;
	gint64 delay_expire_FAILED;

	/* how long we wait before restarting a failed election. */
	gint64 delay_retry_FAILED;

	/* how long we wait after the last USE sent to send a new */
	gint64 delay_ping_final;
	gint64 delay_ping_FAILED;

	gboolean exiting;
};

/* @private */
struct election_member_s
{
	struct election_member_s *prev;
	struct election_member_s *next;

	struct election_manager_s *manager;

	/* Weak pointer to the condition, do not free! */
	GCond *cond;

	gchar *key;

	struct sqlx_name_mutable_s name;

	guint generation_id;

	gint64 when_unstable;
	gint64 last_status; /* last time the status was changed */
	gint64 last_USE; /* last time a USE request has been sent */
	gint64 last_atime; /* last time the app wanted a status */

	gint64 myid; /* ID generated by zookeeper */
	gint64 master_id; /* ID of the master */
	gchar *master_url; /* First node of the children sequence (sorted by ID) */

	guint refcount;

	guint16 pending_GETVERS; /* not finished yet */
	guint16 count_GETVERS; /* initially sent */
	guint16 outdated_GETVERS; /* finished, ask RESYNC */
	guint16 concurrent_GETVERS; /* Finished, shows race condition */
	guint16 errors_GETVERS; /* Finished, no result */

	guint log_index : 8;
	enum election_step_e step : 8;

	/* flags managing unconventional transsitions */
	unsigned char requested_USE : 1;
	unsigned char requested_PIPEFROM : 1;
	unsigned char requested_LEAVE : 1;
	unsigned char requested_LEFT_SELF : 1;
	unsigned char requested_LEFT_MASTER : 1;

	/* Request started, waiting for the status */
	unsigned char pending_PIPEFROM : 1;
	unsigned char pending_ZK_CREATE : 1;
	unsigned char pending_ZK_EXISTS : 1;
	unsigned char pending_ZK_LIST : 1;
	unsigned char pending_ZK_GET : 1;
	unsigned char pending_ZK_DELETE : 1;

	struct logged_event_s log[EVENTLOG_SIZE];
};

gint64 oio_election_period_cond_wait = G_TIME_SPAN_SECOND;

static void _noop (gpointer p) { (void)p; }

static GPrivate th_local_key_manager = G_PRIVATE_INIT(_noop);

#define ON_STATE(N) do { if (state == ZOO_##N##_STATE) return #N; } while (0)
#define ON_ZEVT(N) do { if (zevt == ZOO_##N##_EVENT) return #N; } while (0)

static const char * zoo_state2str(int state) {
	ON_STATE(EXPIRED_SESSION);
	ON_STATE(AUTH_FAILED);
	ON_STATE(CONNECTING);
	ON_STATE(ASSOCIATING);
	ON_STATE(CONNECTED);
	return "STATE?";
}

static const char * zoo_zevt2str(int zevt) {
	ON_ZEVT(CREATED);
	ON_ZEVT(DELETED);
	ON_ZEVT(CHANGED);
	ON_ZEVT(CHILD);
	ON_ZEVT(SESSION);
	ON_ZEVT(NOTWATCHING);
	return "EVENT?";
}

static const char * _step2str(enum election_step_e step) {
	switch (step) {
		ON_ENUM(STEP_,NONE);
		ON_ENUM(STEP_,CREATING);
		ON_ENUM(STEP_,WATCHING);
		ON_ENUM(STEP_,LISTING);
		ON_ENUM(STEP_,LEAVING);
		ON_ENUM(STEP_,LEAVING_FAILING);
		ON_ENUM(STEP_,ASKING);
		ON_ENUM(STEP_,CHECKING_MASTER);
		ON_ENUM(STEP_,CHECKING_SLAVES);
		ON_ENUM(STEP_,SYNCING);
		ON_ENUM(STEP_,SLAVE);
		ON_ENUM(STEP_,MASTER);
		ON_ENUM(STEP_,FAILED);
	}

	return "STEP?";
}

static const char * _evt2str(enum event_type_e evt) {
	switch (evt) {
		ON_ENUM(EVT_,NONE);

		ON_ENUM(EVT_,DISCONNECTED);
		ON_ENUM(EVT_,LEAVE_REQ);
		ON_ENUM(EVT_,SYNC_REQ);
		ON_ENUM(EVT_,LEFT_SELF);
		ON_ENUM(EVT_,LEFT_MASTER);

		ON_ENUM(EVT_,GETVERS_OK);
		ON_ENUM(EVT_,GETVERS_KO);
		ON_ENUM(EVT_,GETVERS_OLD);
		ON_ENUM(EVT_,GETVERS_RACE);

		ON_ENUM(EVT_,CREATE_OK);
		ON_ENUM(EVT_,CREATE_KO);

		ON_ENUM(EVT_,MASTER_KO);
		ON_ENUM(EVT_,MASTER_BAD);
		ON_ENUM(EVT_,MASTER_OK);

		ON_ENUM(EVT_,EXISTS_OK);
		ON_ENUM(EVT_,EXISTS_KO);

		ON_ENUM(EVT_,LIST_OK);
		ON_ENUM(EVT_,LIST_KO);

		ON_ENUM(EVT_,LEAVE_OK);
		ON_ENUM(EVT_,LEAVE_KO);

		ON_ENUM(EVT_,SYNC_OK);
		ON_ENUM(EVT_,SYNC_KO);
	}

	return "EVENT?";
}

static gboolean _zoo_disconnected(int zrc) {
	switch (zrc) {
		case ZRUNTIMEINCONSISTENCY:
		case ZDATAINCONSISTENCY:
		case ZMARSHALLINGERROR:
		case ZUNIMPLEMENTED:
		case ZINVALIDSTATE:
		case ZSESSIONEXPIRED:
		case ZAUTHFAILED:
			return TRUE;
		default:
			return FALSE;
	}
}

/* ------------------------------------------------------------------------- */

static void member_unref(struct election_member_s *member);
static void member_destroy(struct election_member_s *member);

static void _manager_clean(struct election_manager_s *manager);

enum election_mode_e _manager_get_mode (const struct election_manager_s *manager);

const char * _manager_get_local (const struct election_manager_s *manager);

static GError * _election_get_peers(struct election_manager_s *manager,
		const struct sqlx_name_s *n, gboolean nocache, gchar ***peers);


static GError * _election_trigger_RESYNC(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static GError * _election_init(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static GError * _election_start(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static GError * _election_exit(struct election_manager_s *manager,
		const struct sqlx_name_s *n);

static enum election_status_e _election_get_status(struct election_manager_s *m,
		const struct sqlx_name_s *n, gchar **master_url);

static struct election_manager_vtable_s VTABLE =
{
	_manager_clean,
	_manager_get_mode,
	_manager_get_local,
	_election_get_peers,
	_election_init,
	_election_start,
	_election_exit,
	_election_get_status,
	_election_trigger_RESYNC,
};

static void transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc);

static void transition(struct election_member_s *member,
		enum event_type_e evt_type, void *evt_arg);

static gboolean wait_for_final_status(struct election_member_s *m,
		gint64 deadline);

static int gint64_cmp(register gint64 i1, register gint64 i2) { return CMP(i1,i2); }

static int
gint64_sort(gconstpointer p1, gconstpointer p2)
{
	return gint64_cmp(*(gint64*)p1, *(gint64*)p2);
}

static void
_thlocal_set_manager (struct election_manager_s *manager)
{
	g_private_replace (&th_local_key_manager, manager);
}

static struct election_manager_s *
_thlocal_get_manager (void)
{
	return g_private_get (&th_local_key_manager);
}

static void
_cond_clean (gpointer p)
{
	GCond *cond = p;
	if (cond) {
		g_cond_clear (cond);
		g_free (cond);
	}
}

/* -------------------------------------------------------------------------- */

static void
_DEQUE_remove (struct election_member_s *m)
{
	EXTRA_ASSERT(m != NULL);
	EXTRA_ASSERT(m->step < STEP_MAX);
	struct deque_beacon_s *beacon = m->manager->members_by_state + m->step;
	EXTRA_ASSERT(beacon->count > 0);

	struct election_member_s *prev = m->prev, *next = m->next;
	if (beacon->front == m) beacon->front = next;
	if (beacon->back == m) beacon->back = prev;
	if (prev) prev->next = next;
	if (next) next->prev = prev;
	m->prev = m->next = NULL;
	-- beacon->count;
}

static void
_DEQUE_add (struct election_member_s *m)
{
	EXTRA_ASSERT(m != NULL);
	EXTRA_ASSERT(m->step < STEP_MAX);
	EXTRA_ASSERT(m->prev == NULL);
	EXTRA_ASSERT(m->next == NULL);
	struct deque_beacon_s *beacon = m->manager->members_by_state + m->step;

	if (beacon->back) {
		m->prev = beacon->back;
		beacon->back->next = m;
	}
	beacon->back = m;
	if (!beacon->front)
		beacon->front = m;
	++ beacon->count;
}

/* --- Misc helpers --------------------------------------------------------- */

static gboolean
_is_over (const gint64 last, const gint64 delay)
{
	if (!last) return FALSE;
	const gint64 now = oio_ext_monotonic_time ();
	return last < OLDEST(now,delay);
}

static GArray *
nodev_to_int64v(const struct String_vector *sv, const char *prefix)
{
	GArray *array = g_array_new(0, 0, sizeof(gint64));

	for (int32_t i = 0; i < sv->count; i++) {
		const char *s = sv->data[i];
		if (g_str_has_prefix(s, prefix)) {
			const char *stripe = strrchr(s, '-');
			if (stripe != NULL) {
				stripe ++;
				if (strlen(stripe) != 10)
					continue;
				gint64 i64 = 0;
				if (oio_str_is_number(stripe, &i64))
					g_array_append_vals(array, &i64, 1);
			}
		}
	}

	if (array->len > 1)
		g_array_sort(array, gint64_sort);

	return array;
}

/* Public API --------------------------------------------------------------- */

void
election_manager_dump_delays(struct election_manager_s *manager)
{
	GRID_INFO("Election delays:");
	GRID_INFO("- get_status=%ldms but nowait after %ldms",
			manager->delay_wait / G_TIME_SPAN_MILLISECOND,
			manager->delay_nowait_pending / G_TIME_SPAN_MILLISECOND);
	GRID_INFO("- expire_SLAVE=%ldms, expire_MASTER=%ldms",
			manager->delay_expire_SLAVE / G_TIME_SPAN_MILLISECOND,
			manager->delay_expire_MASTER / G_TIME_SPAN_MILLISECOND);
	GRID_INFO("- expire_NONE=%ldms, expire_FAILED=%ldms",
			manager->delay_expire_NONE / G_TIME_SPAN_MILLISECOND,
			manager->delay_expire_FAILED / G_TIME_SPAN_MILLISECOND);
	GRID_INFO("- retry_failed=%ldms",
			manager->delay_retry_FAILED/ G_TIME_SPAN_MILLISECOND);
	GRID_INFO("- ping_failed=%ldms, ping_final=%ldms",
			manager->delay_ping_FAILED / G_TIME_SPAN_MILLISECOND,
			manager->delay_ping_final / G_TIME_SPAN_MILLISECOND);
}

GError *
election_manager_create(struct replication_config_s *config,
		struct election_manager_s **result)
{
	EXTRA_ASSERT(result != NULL);
	EXTRA_ASSERT(config != NULL);

	*result = NULL;
	if (NULL == config->get_local_url || NULL == config->get_peers
			|| NULL == config->get_version || ELECTION_MODE_GROUP < config->mode)
		return NEWERROR(ERRCODE_PARAM, "Invalid configuration");

	struct election_manager_s *manager = g_malloc0(sizeof(*manager));
	manager->vtable = &VTABLE;
	manager->delay_wait = SQLX_DELAY_MAXWAIT;
	manager->delay_nowait_pending = SQLX_DELAY_NOWAIT_PENDING;
	manager->delay_expire_NONE = SQLX_DELAY_EXPIRE_NONE;
	manager->delay_expire_SLAVE = SQLX_DELAY_EXPIRE_SLAVE;
	/* The leader must expire after the slaves or its leaving
	 * will trigger an event on the slaves that will bring it back. */
	manager->delay_expire_MASTER =
		(SQLX_DELAY_EXPIRE_SLAVE + SQLX_DELAY_PING_FINAL) / 2;
	manager->delay_expire_FAILED = SQLX_DELAY_EXPIRE_FAILED;
	manager->delay_retry_FAILED = SQLX_DELAY_RESTART_FAILED;
	manager->delay_ping_final = SQLX_DELAY_PING_FINAL;
	manager->delay_ping_FAILED = SQLX_DELAY_PING_FAILED;
	manager->config = config;

	g_mutex_init(&manager->lock);

	manager->members_by_key =
		g_tree_new_full(metautils_strcmp3, NULL, NULL, NULL);

	manager->conditions =
		g_tree_new_full(metautils_strcmp3, NULL, g_free, _cond_clean);

	*result = manager;
	return NULL;
}

void
election_manager_set_sync (struct election_manager_s *manager,
		struct sqlx_sync_s *sync)
{
	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(sync != NULL);
	EXTRA_ASSERT(manager->vtable == &VTABLE);
	manager->sync = sync;
}

void
election_manager_set_peering (struct election_manager_s *manager,
		struct sqlx_peering_s *peering)
{
	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(peering != NULL);
	EXTRA_ASSERT(manager->vtable == &VTABLE);
	manager->peering = peering;
}

GError *
election_has_peers (struct election_manager_s *m, const struct sqlx_name_s *n,
		gboolean nocache, gboolean *result)
{
	gchar **peers = NULL;
	GError *err = election_get_peers (m, n, nocache, &peers);
	if (err != NULL) {
		*result = FALSE;
		return err;
	}
	*result = peers != NULL && peers[0] != NULL;
	if (peers)
		g_strfreev(peers);
	return NULL;
}

GError *
election_get_peers (struct election_manager_s *m, const struct sqlx_name_s *n,
		gboolean nocache, gchar ***peers)
{
	if (!m) {
		if (peers)
			*peers = g_malloc0(sizeof(void*));
		return NULL;
	}
	return ((struct abstract_election_manager_s*)m)->vtable->election_get_peers
		(m,n,nocache,peers);
}

const char *
election_manager_get_local (const struct election_manager_s *m)
{
	if (!m)
		return NULL;
	return ((struct abstract_election_manager_s*)m)->vtable->get_local(m);
}

enum election_mode_e
election_manager_get_mode (const struct election_manager_s *m)
{
	if (!m)
		return ELECTION_MODE_NONE;
	return ((struct abstract_election_manager_s*)m)->vtable->get_mode(m);
}

static struct election_counts_s
_NOLOCK_count (struct election_manager_s *manager)
{
	struct election_counts_s count = {0};
	count.none = manager->members_by_state[STEP_NONE].count;
	count.pending += manager->members_by_state[STEP_CREATING].count;
	count.pending += manager->members_by_state[STEP_WATCHING].count;
	count.pending += manager->members_by_state[STEP_LISTING].count;
	count.pending += manager->members_by_state[STEP_LEAVING].count;
	count.pending += manager->members_by_state[STEP_LEAVING_FAILING].count;
	count.pending += manager->members_by_state[STEP_ASKING].count;
	count.pending += manager->members_by_state[STEP_CHECKING_MASTER].count;
	count.pending += manager->members_by_state[STEP_CHECKING_SLAVES].count;
	count.pending += manager->members_by_state[STEP_SYNCING].count;
	count.slave = manager->members_by_state[STEP_SLAVE].count;
	count.master = manager->members_by_state[STEP_MASTER].count;
	count.failed = manager->members_by_state[STEP_FAILED].count;
	count.total = count.none + count.pending + count.master + count.slave + count.failed;
	return count;
}

struct election_counts_s
election_manager_count(struct election_manager_s *manager)
{
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);

	g_mutex_lock(&manager->lock);
	struct election_counts_s count = _NOLOCK_count (manager);
	g_mutex_unlock(&manager->lock);
	return count;
}

static GError *
_election_get_peers(struct election_manager_s *manager,
		const struct sqlx_name_s *n, gboolean nocache, gchar ***result)
{
	SQLXNAME_CHECK(n);

	if (!manager || !manager->config || !manager->config->get_peers) {
		if (result)
			*result = NULL;
		return NULL;
	}

	gchar **peers = NULL;
	GError *err = manager->config->get_peers(manager->config->ctx, n, nocache, &peers);
	if (!err) {
		if (result)
			*result = peers;
		else
			g_strfreev (peers);
		return NULL;
	}
	if (peers) {
		g_strfreev (peers);
		peers = NULL;
	}

	g_prefix_error(&err, "get_peers(%s,%s): ", n->base, n->type);
	return err;
}

static void
_manager_clean(struct election_manager_s *manager)
{
	if (!manager)
		return;

	struct election_counts_s count = _NOLOCK_count(manager);
	GRID_DEBUG("%d elections still alive at manager shutdown: %d masters, "
			"%d slaves, %d pending, %d failed, %d exited",
			count.total, count.master, count.slave, count.pending,
			count.failed, count.none);

	if (manager->members_by_key)
		g_tree_destroy (manager->members_by_key);

	/* Ensure all the items are unlinked */
	for (int i=STEP_NONE; i<STEP_MAX ;++i) {
		struct deque_beacon_s *beacon = manager->members_by_state + i;
		while (beacon->front != NULL) {
			struct election_member_s *m = beacon->front;
			_DEQUE_remove(m);
			m->refcount = 0; /* ugly quirk that cope with an assert on refcount */
			member_destroy (m);
		}
		g_assert (beacon->count == 0);
	}

	g_mutex_clear(&manager->lock);
	if (manager->conditions) {
		g_tree_destroy(manager->conditions);
		manager->conditions = NULL;
	}
	g_free(manager);
}

const char *
_manager_get_local (const struct election_manager_s *manager)
{
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);
	if (!manager->config || !manager->config->get_local_url)
		return NULL;
	return manager->config->get_local_url (manager->config->ctx);
}

enum election_mode_e
_manager_get_mode (const struct election_manager_s *manager)
{
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);
	if (!manager->config || manager->config->mode <= ELECTION_MODE_NONE)
		return ELECTION_MODE_NONE;
	return manager->config->mode;
}

/* --- Member handling ----------------------------------------------------- */

static void
member_descr(const struct election_member_s *m, gchar *d, gsize ds)
{
	g_snprintf(d, ds,
			"%s %"G_GINT64_FORMAT"/%"G_GINT64_FORMAT"/%s %u %u/%u/%u/%u [%s] [%s.%s]",
			_step2str(m->step), m->myid, m->master_id,
			(m->master_url ? m->master_url : "-"),
			m->refcount, m->pending_PIPEFROM,
			m->pending_GETVERS, m->errors_GETVERS, m->concurrent_GETVERS,
			m->key, m->name.base, m->name.type);
}

#define DUMP(LVL,TAG,M) do { \
	if (GRID_##LVL##_ENABLED()) { \
		gchar d[256]; \
		member_descr(m, d, sizeof(d)); \
		GRID_##LVL("%s %s", TAG, d); \
	} \
} while (0)

#ifdef HAVE_EXTRA_DEBUG
static void
member_trace(const char *tag, const struct election_member_s *m)
{
	DUMP(TRACE,tag,m);
}
#else
#define member_trace(...)
#endif

static void
member_debug(const char *tag, const struct election_member_s *m)
{
	DUMP(DEBUG,tag,m);
}

static void
member_warn(const char *tag, const struct election_member_s *m)
{
	DUMP(WARN,tag,m);
}

#ifdef HAVE_EXTRA_ASSERT
static gboolean
member_has_getvers (struct election_member_s *m)
{
	return m->count_GETVERS > 0
		|| m->pending_GETVERS > 0
		|| m->outdated_GETVERS > 0
		|| m->concurrent_GETVERS > 0
		|| m->errors_GETVERS > 0;
}

static gboolean
member_has_action(struct election_member_s *m)
{
	return m->pending_GETVERS > 0
		|| m->pending_PIPEFROM
		|| m->pending_ZK_CREATE
		|| m->pending_ZK_EXISTS
		|| m->pending_ZK_LIST
		|| m->pending_ZK_GET
		|| m->pending_ZK_DELETE;
}
#endif

static const char*
member_get_url(struct election_member_s *m)
{
	return election_manager_get_local(MMANAGER(m));
}

static GError *
member_get_peers(struct election_member_s *m, gboolean nocache, gchar ***peers)
{
	return election_get_peers(MMANAGER(m),
			sqlx_name_mutable_to_const(&m->name), nocache, peers);
}

static void
member_decache_peers(struct election_member_s *m)
{
	GError *err = member_get_peers(m, TRUE, NULL);
	if (err) g_clear_error(&err);
}

static void
member_ref(struct election_member_s *m)
{
	++ m->refcount;
}

static void
member_unref(struct election_member_s *m)
{
	EXTRA_ASSERT (m->refcount > 0);
	-- m->refcount;
}

static GCond*
member_get_cond(struct election_member_s *m)
{
	return m->cond;
}

static GMutex*
member_get_lock(struct election_member_s *m)
{
	return &(MMANAGER(m)->lock);
}

static void
member_lock(struct election_member_s *m)
{
	g_mutex_lock(member_get_lock(m));
}

static void
member_unlock(struct election_member_s *m)
{
	g_mutex_unlock(member_get_lock(m));
}

static void
member_signal(struct election_member_s *m)
{
	g_cond_signal(member_get_cond(m));
}

#define member_set_master_url(m,u) do { \
	oio_str_replace(&((m)->master_url), u); \
} while (0)

#define member_reset_master(m) do { \
	m->master_id = -1; \
	member_set_master_url(m, NULL); \
} while (0)

#define member_set_id(m,id) do { \
	EXTRA_ASSERT(id >= 0); \
	EXTRA_ASSERT(m->myid <= 0); \
	m->myid = id; \
} while (0)

#define member_set_master_id(m,i64) do { \
	EXTRA_ASSERT(i64 >= 0); \
	if (i64 != m->master_id) { \
		member_set_master_url(m, NULL); \
		m->master_id = i64; \
	} \
} while (0)

static void
member_reset_getvers(struct election_member_s *m)
{
	m->pending_GETVERS = 0;
	m->count_GETVERS = 0;
	m->concurrent_GETVERS = 0;
	m->outdated_GETVERS = 0;
	m->errors_GETVERS = 0;
}

static void
member_reset_pending(struct election_member_s *m)
{
	m->pending_PIPEFROM = 0;
	m->pending_ZK_CREATE = 0;
	m->pending_ZK_EXISTS = 0;
	m->pending_ZK_LIST = 0;
	m->pending_ZK_GET = 0;
	m->pending_ZK_DELETE = 0;
}

static void
member_reset(struct election_member_s *m)
{
	m->myid = -1;
	member_reset_master(m);
	member_reset_getvers(m);
	member_reset_pending(m);
	/* do not reset the `requested_*` fields, those must survive,
	 * typically to a restart, e.g. to perform a final resync */
}

static gboolean
_state_is_stable(enum election_step_e step)
{
	switch (step) {
		case STEP_CREATING:
		case STEP_WATCHING:
		case STEP_LISTING:
		case STEP_LEAVING:
		case STEP_LEAVING_FAILING:
		case STEP_ASKING:
		case STEP_CHECKING_MASTER:
		case STEP_CHECKING_SLAVES:
		case STEP_SYNCING:
			return FALSE;
		default:
			return TRUE;
	}
}

#define member_is_stable(m) _state_is_stable(m->step)

static void
member_set_status(struct election_member_s *m, const enum election_step_e post)
{
	const enum election_step_e pre = m->step;

	if (pre != post) {
		m->last_status = oio_ext_monotonic_time();
		/* If we leave a non-pending state for a pending state, we keep the
		 * current timestamp, to be able to determine since how long we are
		 * in pending. We will need this to avoid a user-thread to wait if
		 * we are already pending for too long. */
		EXTRA_ASSERT(_state_is_stable(pre) || m->when_unstable != 0);
		if (_state_is_stable(pre) && !_state_is_stable(post))
			m->when_unstable = m->last_status;
		else if (_state_is_stable(post))
			m->when_unstable = 0;
	}

	_DEQUE_remove (m);
	m->step = post;
	_DEQUE_add (m);

	/* send a signal to wake all the threads waiting for the election. They
	 * should receive a signal when they have an action to perform with it:
	 * either the status is FINAL and the threads can act, or we re-jumped
	 * to an inactive state and the threads would kickoff a new election. */
	if (STATUS_FINAL(post)) {
		member_debug("FINAL", m);
		member_signal(m);
	} else if (post == STEP_NONE) {
		member_signal(m);
	}
}

static void
member_log_event(struct election_member_s *member, enum election_step_e pre,
		enum event_type_e evt)
{
	struct logged_event_s *plog;
	plog = member->log + ((member->log_index++) % EVENTLOG_SIZE);
	plog->event = evt;
	plog->pre = pre;
	plog->post = member->step;
}

#ifdef HAVE_EXTRA_DEBUG
static void
member_log_completion(const char *tag, int zrc, const struct election_member_s *m)
{
	GRID_TRACE("%s %d/%s [%s.%s] %s", tag, zrc, zerror(zrc),
			m->name.base, m->name.type, m->key);
}
#else
#define member_log_completion(...)
#endif

static gchar *
member_fullpath(struct election_member_s *member)
{
	return (member->myid >= 0)
		? g_strdup_printf("%s-%010"G_GINT64_FORMAT, member->key, member->myid)
		: g_strdup_printf("%s-", member->key);
}

static gchar *
member_masterpath(struct election_member_s *member)
{
	return (member->master_id < 0) ? NULL : g_strdup_printf(
			"%s-%010"G_GINT64_FORMAT, member->key, member->master_id);
}

static void
member_destroy(struct election_member_s *member)
{
	if (!member)
		return;

	EXTRA_ASSERT (member->refcount == 0);

	member->cond = NULL;
	oio_str_clean (&member->master_url);
	g_free0 (member->key);
	sqlx_name_clean (&member->name);

	memset(member, 0, sizeof(*member));
	member->myid = member->master_id = -1;
	g_free(member);
}

static struct election_member_s *
_LOCKED_get_member (struct election_manager_s *ma, const char *k)
{
	struct election_member_s *m = g_tree_lookup (ma->members_by_key, k);
	if (m)
		member_ref (m);
	return m;
}

static GCond *
_manager_get_condition (struct election_manager_s *m, const char *k)
{
	GCond *cond = g_tree_lookup (m->conditions, k);
	if (!cond) {
		cond = g_malloc0 (sizeof(GCond));
		g_cond_init (cond);
		g_tree_replace (m->conditions, g_strdup(k), cond);
	}
	return cond;
}

static struct election_member_s *
_LOCKED_init_member(struct election_manager_s *manager,
		const struct sqlx_name_s *n, gboolean autocreate)
{
	MANAGER_CHECK(manager);
	NAME_CHECK(n);

	gchar *key = sqliterepo_hash_name(n);
	struct election_member_s *member = _LOCKED_get_member (manager, key);
	if (!member && autocreate) {
		member = g_malloc0 (sizeof(*member));
		member->generation_id = oio_ext_rand_int();
		member->manager = manager;
		member->last_status = oio_ext_monotonic_time ();
		member->key = key;
		member->name.base = g_strdup(n->base);
		member->name.type = g_strdup(n->type);
		member->name.ns = g_strdup(n->ns);
		member->myid = member->master_id = -1;
		member->refcount = 2;
		member->cond = _manager_get_condition(manager, key);

		_DEQUE_add (member);
		g_tree_replace(manager->members_by_key, member->key, member);
		key = NULL;
	} else {
		g_free(key);
	}
	return member;
}

static struct election_member_s *
manager_get_member (struct election_manager_s *m, const char *k)
{
	g_mutex_lock (&m->lock);
	struct election_member_s *member = _LOCKED_get_member (m, k);
	g_mutex_unlock (&m->lock);
	return member;
}

static guint
manager_count_active(struct election_manager_s *manager)
{
	struct election_counts_s count = election_manager_count (manager);
	return count.pending + count.master + count.slave;
}

static gboolean
_run_exit (gpointer k, gpointer v, gpointer i)
{
	(void) k, (void) i;
	struct election_member_s *m = v;
	if (m->step != STEP_NONE
			&& m->step != STEP_LEAVING
			&& m->step != STEP_LEAVING_FAILING)
		transition(m, EVT_LEAVE_REQ, NULL);
	return FALSE;
}

void
election_manager_exit_all(struct election_manager_s *manager, gint64 duration,
		gboolean persist)
{
	GRID_INFO("Voluntarily exiting all the elections...");
	MANAGER_CHECK(manager);
	EXTRA_ASSERT (manager->vtable == &VTABLE);
	gint64 pivot = oio_ext_monotonic_time () + duration;

	/* Order the nodes to exit */
	g_mutex_lock(&manager->lock);
	manager->exiting = TRUE;
	g_tree_foreach (manager->members_by_key, _run_exit, NULL);
	g_mutex_unlock(&manager->lock);

	guint count = manager_count_active(manager);
	if (duration <= 0) {
		GRID_INFO("%u elections still active", count);
	} else {
		do {
			GRID_INFO("Waiting for %u active elections", count);
			if (oio_ext_monotonic_time() > pivot) {
				GRID_WARN("TIMEOUT while waiting for active elections");
				break;
			}
			g_usleep(500 * G_TIME_SPAN_MILLISECOND);
		} while ((count = manager_count_active(manager)) > 0);
		if (count == 0)
			GRID_INFO("No more active elections");
	}

	if (!persist)
		manager->exiting = FALSE;
}

#define GS_APPEND_LEN(gs,str) g_string_append_len(gs, str, sizeof(str)-1);

static void
member_json (struct election_member_s *m, GString *gs)
{
	g_string_append (gs, "{");

	/* description */
	g_string_append (gs, "\"local\":{");
	oio_str_gstring_append_json_pair_int (gs, "id", m->myid);
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair (gs, "url", member_get_url(m));
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair (gs, "state", _step2str(m->step));
	g_string_append (gs, "},\"master\":{");
	oio_str_gstring_append_json_pair_int (gs, "id", m->master_id);
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair (gs, "url", m->master_url);
	g_string_append (gs, "},\"base\":{");
	oio_str_gstring_append_json_pair (gs, "name", m->name.base);
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair (gs, "type", m->name.type);
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair (gs, "zk", m->key);
	g_string_append (gs, "},\"#\":{");
	oio_str_gstring_append_json_pair_int (gs, "R", m->refcount);
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair_int (gs, "P", m->pending_PIPEFROM);
	g_string_append_c (gs, ',');
	oio_str_gstring_append_json_pair_int (gs, "V", m->pending_GETVERS);
	g_string_append_c (gs, '}');

	/* the peers */
	GS_APPEND_LEN(gs, ",\"peers\":");
	gchar **peers = NULL;
	GError *err = member_get_peers(m, FALSE, &peers);
	if (err != NULL) {
		g_string_append_printf(gs, "{\"status\":%d", err->code);
		oio_str_gstring_append_json_pair (gs, "message", err->message);
		g_string_append_c (gs, '}');
	} else if (peers) {
		g_string_append_c (gs, '[');
		for (gchar **p = peers; *p ;p++) {
			if (p!=peers) g_string_append_c(gs, ',');
			oio_str_gstring_append_json_quote(gs, *p);
		}
		g_strfreev(peers);
		g_string_append_c (gs, ']');
	} else {
		GS_APPEND_LEN(gs, "null");
	}

	/* then the livelog */
	GS_APPEND_LEN(gs, ",\"log\":[");
	guint idx = m->log_index - 1;
	for (guint i=0; i<EVENTLOG_SIZE ;i++,idx--) {
		struct logged_event_s *plog = m->log + (idx % EVENTLOG_SIZE);
		if (!plog->pre && !plog->post)
			break;
		if (i!=0)
			g_string_append_c(gs, ',');
		g_string_append_printf(gs, "\"%s:%s:%s\"", _step2str(plog->pre),
				_evt2str(plog->event), _step2str(plog->post));
	}
	g_string_append_c (gs, ']');

	g_string_append_c (gs, '}');
}

void
election_manager_whatabout (struct election_manager_s *m,
		const struct sqlx_name_s *n, gchar *d, gsize ds)
{
	NAME_CHECK(n);
	MANAGER_CHECK(m);
	EXTRA_ASSERT (m->vtable == &VTABLE);
	EXTRA_ASSERT(d != NULL);
	EXTRA_ASSERT(ds > 0);

	gchar *key = sqliterepo_hash_name(n);
	g_mutex_lock(&m->lock);
	struct election_member_s *member = _LOCKED_get_member(m, key);
	g_free(key);

	GString *gs = g_string_new("");
	if (member) {
		member_json (member, gs);
		member_unref (member);
	} else {
		if (election_manager_get_mode(m) == ELECTION_MODE_NONE)
			g_string_append (gs, "{}");
		else
			g_string_append (gs, "null");
	}
	g_mutex_unlock(&m->lock);

	g_strlcpy (d, gs->str, ds);
	g_string_free (gs, TRUE);
}

/* --- Zookeeper callbacks ----------------------------------------------------
 * All of them are called from the zookeeper's thread.
 * We chose to set the election manager in a thread-local slot because ZK
 * contexts for callbackks currently (3.4.6) require that no memory is
 * allocated, especially because of a memory leak on discarded clone watchers.
 * We are forced to pass an integer cast into pointer so that watchers can use
 * them to recover the right election.
 * -------------------------------------------------------------------------- */

static void
completion_DeleteRogueNode(int zrc, const void *d)
{
	gchar *path = (gchar*)d;
	if (zrc == ZNONODE) {
		GRID_DEBUG("Rogue disappeared %s", path);
	} else if (zrc == ZOK) {
		GRID_DEBUG("Rogue deleted %s", path);
	} else {
		GRID_WARN("Rogue deletion error %s: %s", path, zerror(zrc));
	}
	g_free(path);
}

static void
completion_CREATING(int zrc, const char *path, const void *d)
{
	struct election_member_s *member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_log_completion("CREATE", zrc, member);

	member_lock(member);
	_thlocal_set_manager (member->manager);
	if (zrc != ZOK) {
		transition_error(member, EVT_CREATE_KO, zrc);
	} else {
		gint64 id = g_ascii_strtoll(strrchr(path, '-')+1, NULL, 10);
		transition(member, EVT_CREATE_OK, &id);
	}
	member_unref(member);
	member_unlock(member);
}

static void
completion_WATCHING(int zrc, const struct Stat *s UNUSED, const void *d)
{
	struct election_member_s *member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_log_completion("WATCH", zrc, member);

	member_lock(member);
	if (zrc == ZNONODE) {
		transition(member, EVT_LEFT_SELF, NULL);
		/* LEFT_SELF is not enough, this is an interruption that won't move
		 * the FSM forward */
		transition(member, EVT_EXISTS_KO, NULL);
	} else if (zrc != ZOK) {
		transition_error(member, EVT_EXISTS_KO, zrc);
	} else {
		transition(member, EVT_EXISTS_OK, NULL);
	}
	member_unref(member);
	member_unlock(member);
}

static void
completion_LISTING(int zrc, const struct String_vector *sv,
		const void *data)
{
	struct election_member_s *member = (struct election_member_s *) data;
	MEMBER_CHECK(member);
	member_log_completion("LIST", zrc, member);

	member_lock(member);
	if (zrc != ZOK)
		transition_error(member, EVT_LIST_KO, zrc);
	else {
		gint64 first = -1;
		GArray *i64v = nodev_to_int64v(sv, member->key);
		if (i64v->len > 0)
			first = g_array_index(i64v, gint64, 0);
		g_array_free(i64v, TRUE);
		transition(member, EVT_LIST_OK, &first);
	}
	member_unref(member);
	member_unlock(member);
}

static void
completion_ASKING(int zrc, const char *v, int vlen,
		const struct Stat *s UNUSED, const void *d)
{
	struct election_member_s *member = (struct election_member_s *)d;
	MEMBER_CHECK(member);
	member_log_completion("ASK", zrc, member);

	gchar *master = (v && vlen && *v) ? g_strndup(v, vlen) : NULL;
	member_lock(member);

	if (zrc != ZOK) {
		transition_error(member, EVT_MASTER_KO, zrc);
	} else {
		if (!master || !metautils_url_valid_for_connect(master)) {
			transition(member, EVT_MASTER_BAD, NULL);
		} else {
			const char *myurl = member_get_url(member);
			if (strcmp(master, myurl) == 0) {
				/* JFS: the supposed master carries our ID (i.e. our URL),
				 * if we accept it as-is, we will create a loop on ourselves.
				 * We delete it and pretend there is no master. */
				gchar *path = member_masterpath(member);
				GRID_WARN("Rogue being deleted %s", path);
				int zrc2 = sqlx_sync_adelete(member->manager->sync, path, -1,
						completion_DeleteRogueNode, path);
				if (zrc2 != ZOK) {
					GRID_WARN("Failed! %s", zerror(zrc2));
					g_free(path);
				} // else `path` is freed by the callback

				transition(member, EVT_MASTER_BAD, NULL);
			} else {
				transition(member, EVT_MASTER_OK, master);
			}
		}
	}
	member_unref(member);
	member_unlock(member);
	g_free0 (master);
}

static void
completion_LEAVING(int zrc, const void *d)
{
	struct election_member_s *member = (struct election_member_s *) d;
	MEMBER_CHECK(member);
	member_log_completion("LEAVE", zrc, member);

	member_lock(member);
	if (zrc == ZNONODE) {
		transition(member, EVT_LEAVE_OK, NULL);
	} else if (zrc != ZOK)
		transition_error(member, EVT_LEAVE_KO, zrc);
	else {
		transition(member, EVT_LEAVE_OK, NULL);
	}
	member_unref(member);
	member_unlock(member);
}

/* ------------------------------------------------------------------------- */

static struct election_member_s *
_find_member (const char *path, void *d)
{
	guint gen = GPOINTER_TO_UINT(d);

	struct election_manager_s *manager = _thlocal_get_manager ();
	if (!manager) return NULL;

	const char *slash = strrchr(path, '/');
	if (!slash) return NULL;
	slash ++;

	const char *stripe = strchr(slash, '-');
	if (!stripe) return NULL;

	const size_t len = stripe - slash;
	gchar *key = alloca(1 + len);
	memcpy(key, slash, len);
	key[len] = 0;

	struct election_member_s *member = NULL;
	g_mutex_lock (&manager->lock);
	member = _LOCKED_get_member(manager, key);
	if (member) {
		if (member->generation_id == gen)
			return member;
		GRID_DEBUG("watcher: [%s] obsolete w=%u gen=%u",
				member->key, gen, member->generation_id);
	} else {
		GRID_WARN("watcher: [%s] no election found", key);
	}
	g_mutex_unlock (&manager->lock);
	return NULL;
}

static void
_watch_common(const int type, const int state,
		const char *path, void *d, const int evt)
{
	/* Under some circumstances, we know we will drop the event. No need to
	 * lock anything, let's shortcut in these cases. */
	if (!grid_main_is_running()) {
		GRID_DEBUG("watcher: events ignored (exiting) %s/%s %s",
				zoo_zevt2str(type), zoo_state2str(state), path);
		return;
	}
	if (type != ZOO_SESSION_EVENT && type != ZOO_DELETED_EVENT) {
		GRID_DEBUG("watcher: event ignored (kind) %s/%s %s",
				zoo_zevt2str(type), zoo_state2str(state), path);
		return;
	}

	/* Now let's apply the event to the election, once it is located.
	 * We rely on the path, where the election key is written. */
	struct election_member_s *member = _find_member(path, d);
	if (NULL != member) {
		MEMBER_CHECK(member);

		if (type == ZOO_DELETED_EVENT) {
			/* No need to make noise if the node we just removed ... left */
			if (!member->pending_ZK_DELETE || evt != EVT_LEFT_SELF) {
				GRID_DEBUG("watcher: LEFT (%s) [%s.%s] %s",
						evt == EVT_LEFT_SELF ? "self" : "master",
						member->name.base, member->name.type,
						member->key);
			}
			transition(member, evt, NULL);
		} else if (type == ZOO_SESSION_EVENT) {
			if (state == ZOO_EXPIRED_SESSION_STATE
					|| state == ZOO_AUTH_FAILED_STATE) {
				transition(member, EVT_DISCONNECTED, NULL);
			} else {
				GRID_DEBUG("watcher: event ignored %s %s : %s.%s %s",
						zoo_zevt2str(type), zoo_state2str(state),
						member->name.base, member->name.type, member->key);
			}
		} /* else ... shouldn't happen, because of the initial shortcut */
		member_unref(member);
		member_unlock(member);
	}
}

static void
watch_MASTER(zhandle_t *h UNUSED, int type, int state, const char *path, void *d)
{
	return _watch_common(type, state, path, d, EVT_LEFT_MASTER);
}

static void
watch_SELF(zhandle_t *h UNUSED, int type, int state, const char *path, void *d)
{
	return _watch_common(type, state, path, d, EVT_LEFT_SELF);
}

/* ------------------------------------------------------------------------- */

static void
member_warn_abnormal_event(struct election_member_s *member, int evt)
{
	gchar tag[64];
	g_snprintf(tag, sizeof(tag), "ABNORMAL %02d/%s", evt, _evt2str(evt));
	return member_warn(tag, member);
}

static void
member_warn_failed_action(struct election_member_s *member, int zrc,
		const char *action)
{
	gchar *p = member_fullpath(member);
	GRID_WARN("%s failed [%s.%s] [%s] : (%d) %s", action,
			member->name.base, member->name.type,
			p, zrc, zerror(zrc));
	g_free(p);
}

/* ------------------------------------------------------------------------- */

enum election_op_e {
	ELOP_NONE, ELOP_START, ELOP_RESYNC, ELOP_EXIT
};

static GError *
_election_make(struct election_manager_s *m, const struct sqlx_name_s *n,
		enum election_op_e op)
{
	MANAGER_CHECK(m);
	SQLXNAME_CHECK(n);

	if (op != ELOP_EXIT) {
		gboolean peers_present = FALSE;
		GError *err = election_has_peers(m, n, FALSE, &peers_present);
		if (err != NULL) {
			g_prefix_error(&err, "Election error: ");
			return err;
		}
		if (!peers_present) {
			GRID_DEBUG("No peer for [%s][%s]", n->base, n->type);
			return NULL;
		}
	}

	g_mutex_lock(&m->lock);
	struct election_member_s *member = _LOCKED_init_member(m, n, op != ELOP_EXIT);
	switch (op) {
		case ELOP_NONE:
			member->last_atime = oio_ext_monotonic_time ();
			break;
		case ELOP_START:
			member->last_atime = oio_ext_monotonic_time ();
			transition(member, EVT_NONE, NULL);
			break;
		case ELOP_RESYNC:
			member->last_atime = oio_ext_monotonic_time ();
			transition(member, EVT_SYNC_REQ, NULL);
			break;
		case ELOP_EXIT:
			if (member)
				transition(member, EVT_LEAVE_REQ, NULL);
			break;
	}
	if (member)
		member_unref(member);
	g_mutex_unlock(&m->lock);

	return NULL;
}

static GError *
_election_trigger_RESYNC(struct election_manager_s *manager,
		const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_RESYNC);
}

static GError *
_election_init(struct election_manager_s *manager, const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_NONE);
}

static GError *
_election_start(struct election_manager_s *manager, const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_START);
}

static GError *
_election_exit(struct election_manager_s *manager, const struct sqlx_name_s *n)
{
	return _election_make(manager, n, ELOP_EXIT);
}

static gboolean
wait_for_final_status(struct election_member_s *m, gint64 deadline)
{
	while (!STATUS_FINAL(m->step)) {

		const gint64 now = oio_ext_monotonic_time();

		/* compare internal timers to our fake'able clock */
		if (now > deadline) {
			GRID_WARN("TIMEOUT! (waiting for election status) [%s.%s]",
					m->name.base, m->name.type);
			return FALSE;
		}
		if (m->step == STEP_FAILED) {
			GRID_WARN("TIMEOUT! (election failed) [%s.%s]",
					m->name.base, m->name.type);
			return FALSE;
		}

		m->last_atime = now;
		transition(m, EVT_NONE, NULL);

		if (!member_is_stable(m)) {
			if (m->when_unstable < OLDEST(now, m->manager->delay_nowait_pending)) {
				GRID_WARN("TIMEOUT! (election failed) [%s.%s]",
						m->name.base, m->name.type);
				return FALSE;
			}
		}

		GRID_TRACE("Still waiting for a final status on [%s.%s]",
				m->name.base, m->name.type);

		/* perform the real WAIT on the real clock. */
		g_cond_wait_until(member_get_cond(m), member_get_lock(m),
				g_get_monotonic_time() + oio_election_period_cond_wait);
	}

	m->last_atime = oio_ext_monotonic_time ();
	return TRUE;
}

static enum election_status_e
_election_get_status(struct election_manager_s *mgr,
		const struct sqlx_name_s *n, gchar **master_url)
{
	int rc;
	gchar *url = NULL;

	MANAGER_CHECK(mgr);
	EXTRA_ASSERT(n != NULL);

	gint64 deadline = oio_ext_monotonic_time () + mgr->delay_wait;

	g_mutex_lock(&mgr->lock);
	struct election_member_s *m = _LOCKED_init_member(mgr, n, TRUE);

	if (!wait_for_final_status(m, deadline)) // TIMEOUT!
		rc = STEP_FAILED;
	else {
		rc = m->step;
		if (rc == STEP_SLAVE) {
			if (m->master_url)
				url = g_strdup(m->master_url);
		}
	}

	member_unref(m);
	if (rc == STEP_NONE || STATUS_FINAL(rc))
		member_signal(m);
	member_unlock(m);

	GRID_TRACE("STEP=%s/%d master=%s", _step2str(rc), rc, url);
	switch (rc) {
		case STEP_MASTER:
			return ELECTION_LEADER;
		case STEP_SLAVE:
			if (master_url)
				*master_url = url;
			else
				g_free(url);
			url = NULL;
			return ELECTION_LOST;
		default:
			return ELECTION_FAILED;
	}
}

/* ------------------------------------------------------------------------- */

static gboolean
defer_USE(struct election_member_s *member)
{
	const gint64 now = oio_ext_monotonic_time();

	/* Sometimes, defer_USE() is called after a check for a delay (based on
	 * last_USE), sometimes not. When there is already a check, the delay is
	 * ~ always longer than the following G_TIME_SPAN_SECOND, so this check
	 * is harmless.
	 * However, having a hard limit to a minimum of 1s between 2 USE for the
	 * same election is a good thing, IMO (jfs). */
	if ((now - member->last_USE) < G_TIME_SPAN_SECOND) {
		member_trace("avoid:USE", member);
		return TRUE;
	}

	gchar **peers = NULL;
	GError *err = member_get_peers(member, FALSE, &peers);
	if (err != NULL) {
		GRID_WARN("[%s] Election initiated (%s) but get_peers error: (%d) %s",
				__FUNCTION__, _step2str(member->step), err->code, err->message);
		g_clear_error(&err);
		return FALSE;
	}

	if (!peers || !*peers) {
		member_trace("avoid:USE", member);
	} else {
		member->last_USE = oio_ext_monotonic_time();
		for (gchar **p=peers; p && *p ;p++)
			sqlx_peering__use (member->manager->peering, *p,
					sqlx_name_mutable_to_const(&member->name));
		member_trace("shed:USE", member);
	}

	if (peers) g_strfreev(peers);
	return TRUE;
}

static void
_result_GETVERS (GError *enet,
		struct election_manager_s *manager, const struct sqlx_name_s *name,
		guint reqid, GTree *vremote)
{
	GError *err = NULL;
	GTree *vlocal = NULL;

	EXTRA_ASSERT(manager != NULL);
	EXTRA_ASSERT(name != NULL);
	EXTRA_ASSERT((enet != NULL) ^ (vremote != NULL));

	if (enet) {
		err = g_error_copy(enet);
	} else {
		err = manager->config->get_version (manager->config->ctx, name, &vlocal);
		EXTRA_ASSERT ((err != NULL) ^ (vlocal != NULL));
	}

	if (!err) {
		gint64 worst = 0;
		err = version_validate_diff(vlocal, vremote, &worst);
		if (NULL != err) {
			if (err->code == CODE_PIPETO) {
				GRID_DEBUG("Remote outdated : (%d) %s",
						err->code, err->message);
				g_clear_error(&err);
			}
		} else {
			if (worst < 0)
				err = NEWERROR(CODE_PIPEFROM, "One diff missed");
		}
	}

	gchar *key = sqliterepo_hash_name(name);
	struct election_member_s *member = manager_get_member(manager, key);
	if (!member) {
		GRID_WARN("GETVERS Election disappeared [%s]", key);
	} else {

		MEMBER_CHECK(member);

		member_lock(member);
		if (!err)
			transition(member, EVT_GETVERS_OK, &reqid);
		else if (err->code == CODE_PIPEFROM)
			transition(member, EVT_GETVERS_OLD, &reqid);
		else if (err->code == CODE_CONCURRENT)
			transition(member, EVT_GETVERS_RACE, &reqid);
		else {
			GRID_DEBUG("GETVERS error : (%d) %s", err->code, err->message);
			if (err->code == CODE_CONTAINER_NOTFOUND) {
				// We may have asked the wrong peer
				member_decache_peers(member);
			}
			transition(member, EVT_GETVERS_KO, &reqid);
		}
		member_unlock(member);
	}

	if (err) g_clear_error(&err);
	if (vlocal) g_tree_destroy(vlocal);
	g_free (key);
}

static void
defer_GETVERS_to_peers(struct election_member_s *m)
{
	MEMBER_CHECK(m);

	gchar **peers = NULL;
	GError *err = member_get_peers(m, FALSE, &peers);
	if (err != NULL) {
		GRID_WARN("[%s] Election initiated (%s) but get_peers error: (%d) %s",
				__FUNCTION__, _step2str(m->step), err->code, err->message);
		g_clear_error(&err);
		return;
	}

	if (m->pending_GETVERS > 0)
		member_warn("lost:GETVERS", m);

	const guint pending = peers ? g_strv_length(peers) : 0;
	m->count_GETVERS = m->pending_GETVERS = pending;
	m->concurrent_GETVERS = 0;
	m->outdated_GETVERS = 0;
	m->errors_GETVERS = 0;

	for (gchar **p=peers; p && *p; p++) {
		sqlx_peering__getvers (m->manager->peering, *p,
				sqlx_name_mutable_to_const(&m->name), m->manager,
				0, _result_GETVERS);
		member_trace("shed:GETVERS", m);
	}

	g_strfreev(peers);
}

static void
defer_GETVERS_to_master(struct election_member_s *m)
{
	MEMBER_CHECK(m);
	EXTRA_ASSERT(m->master_url != NULL);

	if (m->pending_GETVERS > 0)
		member_warn("lost:GETVERS", m);

	m->count_GETVERS = m->pending_GETVERS = 1;
	m->outdated_GETVERS = 0;
	m->concurrent_GETVERS = 0;
	m->errors_GETVERS = 0;

	sqlx_peering__getvers (m->manager->peering, m->master_url,
			sqlx_name_mutable_to_const(&m->name), m->manager,
			0, _result_GETVERS);

	member_trace("shed:GETVERS", m);
}

static void
_result_PIPEFROM (GError *e, struct election_manager_s *manager,
		const struct sqlx_name_s *n, guint reqid)
{
	gchar *key = sqliterepo_hash_name(n);

	if (!e || CODE_IS_OK(e->code)) {
		GRID_DEBUG("PIPEFROM ok [%s.%s] [%s]",
				n->base, n->type, key);
	} else {
		GRID_WARN("PIPEFROM failed [%s.%s] [%s]: (%d) %s",
				n->base, n->type, key, e->code, e->message);
	}

	struct election_member_s *member = manager_get_member (manager, key);
	g_free (key);

	if (member) {
		member_lock(member);
		/* We do the transition even if we undergo an error.
		 * This means we are not consistent but eventually consistent. */
		transition(member, EVT_SYNC_OK, &reqid);
		member_unref(member);
		member_unlock(member);
	}
}

/* -------------------------------------------------------------------------- */

static void
member_action_to_NONE(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));
	EXTRA_ASSERT(member->myid == -1);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	member->generation_id ++;
	member_set_status(member, STEP_NONE);
}

/* Gathers a check on the set of actions currently pending and the change of
 * the election status. No action may be pending, and then the election get
 * its FAILED state */
static void
member_action_to_FAILED(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));

	/* setting last_USE to now avoids sending USE as soon as arrived in
	 * the set of FAILED elections. */
	member->last_USE = oio_ext_monotonic_time ();

	member_set_status(member, STEP_FAILED);
}

/* Actual transition */
static void
member_fail_on_error(struct election_member_s *member, int zrc)
{
	if (_zoo_disconnected(zrc))
		return transition(member, EVT_DISCONNECTED, NULL);
	return member_action_to_FAILED(member);
}

static void
_common_action_to_LEAVE(struct election_member_s *member,
		enum event_type_e evt)
{
	EXTRA_ASSERT(!member_has_action(member));

	member->requested_LEAVE = 0;
	member->requested_LEFT_SELF = 0;
	member->requested_LEFT_MASTER = 0;

	gchar *path  = member_fullpath(member);
	int zrc = sqlx_sync_adelete(member->manager->sync,
			path, -1,
			completion_LEAVING, member);
	g_free(path);

	if (unlikely(zrc != ZOK))
		return member_fail_on_error(member, zrc);

	member->pending_ZK_DELETE = 1;
	member_ref(member);
	member_reset_master(member);
	return member_set_status(member, evt);
}

/* Actual transition */
static void
member_action_to_LEAVING(struct election_member_s *member)
{
	return _common_action_to_LEAVE(member, STEP_LEAVING);
}

/* Actual transition */
static void
member_action_to_LEAVING_FAILING(struct election_member_s *member)
{
	return _common_action_to_LEAVE(member, STEP_LEAVING_FAILING);
}

/* Actual transition */
static void
member_leave_on_error(struct election_member_s *member, int zrc)
{
	if (_zoo_disconnected(zrc))
		return transition(member, EVT_DISCONNECTED, NULL);
	return member_action_to_LEAVING_FAILING(member);
}

/* Let's create the node in the ZK service */
static void
member_action_to_CREATING(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));

	const char *myurl = member_get_url(member);
	gchar *path = member_fullpath(member);
	int zrc = sqlx_sync_acreate(member->manager->sync,
			path, myurl, strlen(myurl),
			ZOO_EPHEMERAL|ZOO_SEQUENCE,
			completion_CREATING, member);
	g_free(path);

	if (unlikely(zrc != ZOK)) {
		member_warn_failed_action(member, zrc, "CREATE");
		return member_fail_on_error(member, zrc);
	}

	member->generation_id ++;
	member->pending_ZK_CREATE = 1;
	member_ref(member);
	return member_set_status(member, STEP_CREATING);
}

/* Actual transition */
static void
member_action_to_WATCHING(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));

	gchar *path = member_fullpath(member);
	int zrc = sqlx_sync_awexists(member->manager->sync, path,
			watch_SELF, GUINT_TO_POINTER(member->generation_id),
			completion_WATCHING, member);
	g_free(path);

	if (unlikely(zrc != ZOK)) {
		member_warn_failed_action(member, zrc, "WATCH");
		return member_leave_on_error(member, zrc);
	}

	member->pending_ZK_EXISTS = 1;
	member_ref(member);
	return member_set_status(member, STEP_WATCHING);
}

/* Actual transition */
static void
member_action_to_LISTING(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);

	gchar *path = member_fullpath(member);
	int zrc = sqlx_sync_awget_siblings(member->manager->sync,
			path, NULL, NULL, completion_LISTING, member);
	g_free(path);

	if (unlikely(zrc != ZOK)) {
		member_warn_failed_action(member, zrc, "LIST");
		return member_leave_on_error(member, zrc);
	}

	member->pending_ZK_LIST = 1;
	member_ref(member);
	return member_set_status(member, STEP_LISTING);
}

/* Actual transition */
static void
member_action_to_ASKING(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));

	gchar *path = member_masterpath(member);
	int zrc = sqlx_sync_awget(member->manager->sync, path,
			watch_MASTER, GUINT_TO_POINTER(member->generation_id),
			completion_ASKING, member);
	g_free(path);

	if (unlikely(zrc != ZOK)) {
		member_warn_failed_action(member, zrc, "ASK");
		return member_leave_on_error(member, zrc);
	}

	member->pending_ZK_GET = 1;
	member_ref(member);
	return member_set_status(member, STEP_ASKING);
}

/* Actual transition */
static void
member_action_to_SYNCING(struct election_member_s *member)
{
	EXTRA_ASSERT(!member_has_action(member));

	member_ref(member);

	const char *source = member->master_url;
	const char *target = member_get_url(member);

	EXTRA_ASSERT(target != NULL);
	EXTRA_ASSERT(source != NULL);

	member->requested_PIPEFROM = 0;
	member->pending_PIPEFROM = 1;
	member_set_status(member, STEP_SYNCING);

	sqlx_peering__pipefrom (member->manager->peering, target,
			sqlx_name_mutable_to_const(&member->name), source,
			member->manager, 0, _result_PIPEFROM);

	member_debug("sched:PIPEFROM", member);
}

static void
member_finish_CHECKING_MASTER(struct election_member_s *member)
{
	if ((-- member->pending_GETVERS) > 0)
		return;
	EXTRA_ASSERT(!member_has_action(member));

	const guint16 asked = member->count_GETVERS;
	const guint16 outdated = member->outdated_GETVERS;
	const guint16 errors = member->errors_GETVERS;
	const guint16 concurrent = member->concurrent_GETVERS;

	const guint16 node_left = member->requested_LEFT_SELF;
	const guint16 master_change = member->requested_LEFT_MASTER;

	member->count_GETVERS = 0;
	member->outdated_GETVERS = 0;
	member->errors_GETVERS = 0;
	member->concurrent_GETVERS = 0;

	member->requested_LEFT_SELF = 0;
	member->requested_LEFT_MASTER = 0;

	if (member->requested_LEAVE)
		return member_action_to_LEAVING(member);
	if (master_change)
		return member_action_to_LISTING(member);

	const guint16 group_size = asked + 1;
	if (errors > 0 && (errors >= group_size / 2))
		return member_action_to_LEAVING_FAILING(member);
	if (concurrent)
		return member_action_to_SYNCING(member);
	if (outdated)
		return member_action_to_SYNCING(member);

	if (node_left)
		return member_action_to_CREATING(member);

	member_set_status(member, STEP_SLAVE);
}

static void
member_finish_CHECKING_SLAVES(struct election_member_s *member)
{
	if ((-- member->pending_GETVERS) > 0)
		return;
	EXTRA_ASSERT(!member_has_action(member));

	const guint16 asked = member->count_GETVERS;
	const guint16 outdated = member->outdated_GETVERS;
	const guint16 errors = member->errors_GETVERS;
	const guint16 concurrent = member->concurrent_GETVERS;

	member->count_GETVERS = 0;
	member->outdated_GETVERS = 0;
	member->errors_GETVERS = 0;
	member->concurrent_GETVERS = 0;

	const guint8 node_left = member->requested_LEFT_SELF;

	member->requested_LEFT_SELF = 0;
	member->requested_LEFT_MASTER = 0;

	const guint16 group_size = asked + 1;
	if (errors > 0 && (errors >= group_size / 2))
		return member_action_to_LEAVING_FAILING(member);
	/* FIXME concurrent > 1 ? */
	if (concurrent)
		return member_action_to_LEAVING(member);
	if (outdated)
		return member_action_to_LEAVING(member);
	if (member->requested_LEAVE)
		return member_action_to_LEAVING(member);

	if (node_left)
		return member_action_to_CREATING(member);

	return member_set_status(member, STEP_MASTER);
}

#ifdef HAVE_EXTRA_ASSERT

static void
_member_assert_NONE(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_NONE);
	EXTRA_ASSERT(member->myid == -1);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_action(member));
}

static void
_member_assert_CREATING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_CREATING);
	EXTRA_ASSERT(member->myid == -1);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(member->requested_LEFT_SELF == 0);  // makes no sense
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE != 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_WATCHING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_WATCHING);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS != 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_LISTING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_LISTING);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST != 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_ASKING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_ASKING);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id >= 0);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_GET != 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_CHECKING_MASTER(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_CHECKING_MASTER);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id >= 0);
	EXTRA_ASSERT(member->master_id != member->myid);
	EXTRA_ASSERT(member->master_url != NULL);
	EXTRA_ASSERT(member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_CHECKING_SLAVES(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_CHECKING_SLAVES);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id == member->myid);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(member->requested_LEFT_MASTER == 0);
	EXTRA_ASSERT(member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_LEAVING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_LEAVING);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE != 0);
}

static inline void
_member_assert_LEAVING_FAILING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_LEAVING_FAILING);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM == 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE != 0);
}

static void
_member_assert_SYNCING(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_SYNCING);
	EXTRA_ASSERT(member->myid >= 0);
	EXTRA_ASSERT(member->master_id >= 0);
	EXTRA_ASSERT(member->master_url != NULL);
	EXTRA_ASSERT(!member_has_getvers(member));
	EXTRA_ASSERT(member->pending_PIPEFROM != 0);
	EXTRA_ASSERT(member->pending_ZK_CREATE == 0);
	EXTRA_ASSERT(member->pending_ZK_EXISTS == 0);
	EXTRA_ASSERT(member->pending_ZK_LIST == 0);
	EXTRA_ASSERT(member->pending_ZK_GET == 0);
	EXTRA_ASSERT(member->pending_ZK_DELETE == 0);
}

static void
_member_assert_SLAVE(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_SLAVE);
	EXTRA_ASSERT(member->myid != -1);
	EXTRA_ASSERT(member->master_id != -1);
	EXTRA_ASSERT(member->master_id != member->myid);
	EXTRA_ASSERT(member->master_url != NULL);
	EXTRA_ASSERT(!member_has_action(member));
}

static void
_member_assert_MASTER(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_MASTER);
	EXTRA_ASSERT(member->myid != -1);
	EXTRA_ASSERT(member->master_id == member->myid);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_action(member));
}

static void
_member_assert_FAILED(struct election_member_s *member)
{
	EXTRA_ASSERT(member->step == STEP_FAILED);
	EXTRA_ASSERT(member->myid == -1);
	EXTRA_ASSERT(member->master_id == -1);
	EXTRA_ASSERT(member->master_url == NULL);
	EXTRA_ASSERT(!member_has_action(member));
}

#else
#define _member_assert_NONE(...)
#define _member_assert_CREATING(...)
#define _member_assert_WATCHING(...)
#define _member_assert_LISTING(...)
#define _member_assert_ASKING(...)
#define _member_assert_CHECKING_MASTER(...)
#define _member_assert_CHECKING_SLAVES(...)
#define _member_assert_LEAVING(...)
#define _member_assert_LEAVING_FAILING(...)
#define _member_assert_SYNCING(...)
#define _member_assert_SLAVE(...)
#define _member_assert_MASTER(...)
#define _member_assert_FAILED(...)
#endif

static void
_member_react_NONE(struct election_member_s *member, enum event_type_e evt)
{
	_member_assert_NONE (member);
	switch (evt) {
		case EVT_NONE:
			member->requested_USE = 0;
			if (member->manager->exiting)
				return;
			if (!defer_USE(member))
				return member_action_to_FAILED(member);
			return member_action_to_CREATING(member);

			/* Interruptions */
		case EVT_LEAVE_REQ:
			return;
		case EVT_SYNC_REQ:
			/* Trigger an election that must lead to a PRE-SLAVE
			 * state and then a SYNCING */
			member->requested_PIPEFROM = 1;
			member->requested_USE = 1;
			return;
		case EVT_LEFT_SELF:
		case EVT_LEFT_MASTER:
			return member_warn_abnormal_event(member, evt);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_CREATING(struct election_member_s *member,
		enum event_type_e evt, gint64 *p_myid)
{
	_member_assert_CREATING (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			return;
		case EVT_LEFT_SELF:
			return;
		case EVT_LEFT_MASTER:
			return member_warn_abnormal_event(member, evt);

			/* Actions */
		case EVT_CREATE_KO:
			member->pending_ZK_CREATE = 0;
			return member_action_to_FAILED(member);

		case EVT_CREATE_OK:
			EXTRA_ASSERT(p_myid != NULL);
			EXTRA_ASSERT(*p_myid >= 0);
			member->pending_ZK_CREATE = 0;
			member_set_id(member, *p_myid);
			/* manage interruptions */
			if (member->requested_LEAVE)
				return member_action_to_LEAVING(member);
			/* nominal flow */
			return member_action_to_WATCHING(member);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_WATCHING(struct election_member_s *member, enum event_type_e evt)
{
	_member_assert_WATCHING (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			return;
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;
		case EVT_LEFT_SELF:
			member->requested_LEFT_SELF = 1;
			return;
		case EVT_LEFT_MASTER:
			return member_warn_abnormal_event(member, evt);

			/* Action */
		case EVT_EXISTS_KO:
			member->pending_ZK_EXISTS = 0;
			return member_action_to_LEAVING(member);

		case EVT_EXISTS_OK:
			member->pending_ZK_EXISTS = 0;
			/* manage past interruptions */
			if (member->requested_LEAVE)
				return member_action_to_LEAVING(member);
			if (member->requested_LEFT_SELF)
				return member_action_to_CREATING(member);
			/* nominal flow */
			return member_action_to_LISTING(member);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_LISTING(struct election_member_s *member, enum event_type_e evt,
		gint64 *p_masterid)
{
	_member_assert_LISTING (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			return;
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;
		case EVT_LEFT_SELF:
			member->requested_LEFT_SELF = 1;
			return;
		case EVT_LEFT_MASTER:
			return;

			/* Actions */
		case EVT_LIST_KO:
			member->pending_ZK_LIST = 0;
			return member_action_to_LEAVING_FAILING(member);

		case EVT_LIST_OK:
			member->pending_ZK_LIST = 0;
			/* manage past interruptions */
			if (member->requested_LEAVE)
				return member_action_to_LEAVING(member);
			if (member->requested_LEFT_SELF)
				return member_action_to_CREATING(member);
			/* nominal flow */
			if (member->myid == *p_masterid) {
				/* We are 1st, the probable future master */
				member_set_master_id(member, member->myid);
				defer_GETVERS_to_peers(member);
				return member_set_status(member, STEP_CHECKING_SLAVES);
			} else {
				/* We are in the tail, probable future slave */
				member_set_master_id(member, *p_masterid);
				return member_action_to_ASKING(member);
			}

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_ASKING(struct election_member_s *member, enum event_type_e evt,
		const char *url)
{
	_member_assert_ASKING (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			return;
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;
		case EVT_LEFT_SELF:
			member->requested_LEFT_SELF = 1;
			return;
		case EVT_LEFT_MASTER:
			member->requested_LEFT_MASTER = 1;
			return;

			/* Actions */
		case EVT_MASTER_KO:
			member->pending_ZK_GET = 0;
			EXTRA_ASSERT(url == NULL);
			/* No need to manage a clean LEAVE, we are about to leave
			 * and then fail */
			return member_action_to_LEAVING_FAILING(member);

		case EVT_MASTER_BAD:
			member->pending_ZK_GET = 0;
			EXTRA_ASSERT(url == NULL);
			/* No need to manage a clean LEAVE, we are about to leave
			 * and then fail */
			return member_action_to_LEAVING_FAILING(member);

		case EVT_MASTER_OK:
			member->pending_ZK_GET = 0;
			/* manage past interruptions */
			if (member->requested_LEAVE)
				return member_action_to_LEAVING(member);
			if (member->requested_LEFT_SELF) {
				member->myid = -1;
				member_reset_master(member);
				member->requested_LEFT_SELF = 0;
				member->requested_LEFT_MASTER = 0;
				return member_action_to_CREATING(member);
			}
			if (member->requested_LEFT_MASTER) {
				member_reset_master(member);
				return member_action_to_LISTING(member);
			}
			/* nominal flow : let's become CHECKING_MASTER */
			member_set_master_url(member, url);
			defer_GETVERS_to_master(member);
			return member_set_status(member, STEP_CHECKING_MASTER);

			/* Abnormal */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_CHECKING_MASTER(struct election_member_s *member,
		enum event_type_e evt)
{
	_member_assert_CHECKING_MASTER (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			return;
		case EVT_LEFT_MASTER:
			member->requested_LEFT_MASTER = 1;
			return;
		case EVT_LEFT_SELF:
			member->requested_LEFT_SELF = 1;
			return;
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;

			/* Actions
			 * The acction is ~ the same for every completion event. This is
			 * intentional and is used to have a pretty transition log for
			 * the election FSM. */
		case EVT_GETVERS_OK:
			return member_finish_CHECKING_MASTER(member);

		case EVT_GETVERS_OLD:
			member->outdated_GETVERS ++;
			return member_finish_CHECKING_MASTER(member);

		case EVT_GETVERS_RACE:
			member->concurrent_GETVERS ++;
			return member_finish_CHECKING_MASTER(member);

		case EVT_GETVERS_KO:
			member->errors_GETVERS ++;
			return member_finish_CHECKING_MASTER(member);

			/* Abnormal */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_CHECKING_SLAVES(struct election_member_s *member,
		enum event_type_e evt)
{
	_member_assert_CHECKING_SLAVES (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			return;
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;
		case EVT_LEFT_SELF:
			member->requested_LEFT_SELF = 1;
			return;
		case EVT_LEFT_MASTER:
			return;

			/* Actions */
		case EVT_GETVERS_OK:
			return member_finish_CHECKING_SLAVES(member);

		case EVT_GETVERS_OLD:
			member->outdated_GETVERS ++;
			return member_finish_CHECKING_SLAVES(member);

		case EVT_GETVERS_RACE:
			member->concurrent_GETVERS ++;
			return member_finish_CHECKING_SLAVES(member);

		case EVT_GETVERS_KO:
			member->errors_GETVERS ++;
			return member_finish_CHECKING_SLAVES(member);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_LEAVING(struct election_member_s *member,
		enum event_type_e evt)
{
	_member_assert_LEAVING (member);
	switch (evt) {
		case EVT_NONE:
			member->requested_USE = (0 == member->manager->exiting);
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			member->requested_USE = 1;
			return;
		case EVT_LEAVE_REQ:
		case EVT_LEFT_SELF:
		case EVT_LEFT_MASTER:
			return;

			/* Actions */
		case EVT_LEAVE_KO:
			/* The clean "leaving" action failed, let's retry once then
			 * fail the election. The case of zrc==ZNONODE has already
			 * been managed, and assimilated to a success. */
			member->pending_ZK_DELETE = 0;
			return member_action_to_LEAVING_FAILING(member);

		case EVT_LEAVE_OK:
			member->pending_ZK_DELETE = 0;
			member->myid = -1;
			member_reset_master(member);
			return member_action_to_NONE(member);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_LEAVING_FAILING(struct election_member_s *member,
		enum event_type_e evt)
{
	_member_assert_LEAVING_FAILING (member);
	switch (evt) {
		case EVT_NONE:
			member->requested_USE = 1;
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			member->requested_USE = 1;
			return;
		case EVT_LEAVE_REQ:
		case EVT_LEFT_SELF:
		case EVT_LEFT_MASTER:
			return;

			/* Actions */
		case EVT_LEAVE_KO:
		case EVT_LEAVE_OK:
			member->pending_ZK_DELETE = 0;
			member->myid = -1;
			member_reset_master(member);
			return member_action_to_FAILED(member);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_SYNCING(struct election_member_s *member, enum event_type_e evt)
{
	_member_assert_SYNCING (member);
	switch (evt) {
		case EVT_NONE:
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			/* already currently managed */
			return;
		case EVT_LEAVE_REQ:
			member->requested_LEAVE = 1;
			return;
		case EVT_LEFT_SELF:
			member->requested_LEFT_SELF = 1;
			return;
		case EVT_LEFT_MASTER:
			member->requested_LEFT_MASTER = 1;
			return;

			/* Actions */
		case EVT_SYNC_OK:
		case EVT_SYNC_KO:
			member->pending_PIPEFROM = 0;
			if (member->requested_LEAVE)
				return member_action_to_LEAVING(member);
			if (member->requested_LEFT_SELF)
				return member_action_to_CREATING(member);
			if (member->requested_LEFT_MASTER)
				return member_action_to_LISTING(member);
			return member_set_status(member, STEP_SLAVE);

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static gint64
_delay_randomize(const gint64 base, const gint64 jitter)
{
	/* Avoid an overflow on the int32, the delay might represent several days
	 * in microseconds */
	gint64 max = G_MAXINT32 - 1;
	if (base + jitter < max)
		max = base + jitter;
	gint64 min = base - jitter;
	if (min > max)
		min = max;

	/* Introduce a +1 bias to avoid the check of base != 0 */
	return (gint64) oio_ext_rand_int_range(
			(gint32)(min + 1), (gint32)(max + 1));
}

static gint64
_delay_ping_final(const struct election_manager_s *M)
{
	return _delay_randomize(M->delay_ping_final, M->delay_ping_final / 5);
}

static void
_member_react_SLAVE(struct election_member_s *member, enum event_type_e evt)
{
	_member_assert_SLAVE (member);
	const struct election_manager_s *M = member->manager;

	switch (evt) {
		/* Possible time-triggered actions */
		case EVT_NONE:
			if (_is_over (member->last_atime, M->delay_expire_SLAVE))
				return member_action_to_LEAVING(member);
			if (_is_over (member->last_USE, _delay_ping_final(M)))
				defer_USE(member);
			return;

			/* Interruptions */
		case EVT_LEAVE_REQ:
			return member_action_to_LEAVING(member);
		case EVT_LEFT_SELF:
			member_warn("LEFT (self)", member);
			member->myid = -1;
			member_reset_master(member);
			return member_action_to_CREATING(member);
		case EVT_LEFT_MASTER:
			member_reset_master(member);
			return member_action_to_LISTING(member);
		case EVT_SYNC_REQ:
			return member_action_to_SYNCING(member);

			/* Actions: none should be pending */

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_MASTER(struct election_member_s *member, enum event_type_e evt)
{
	_member_assert_MASTER (member);
	const struct election_manager_s *M = member->manager;

	switch (evt) {
		/* Possible time-triggered actions */
		case EVT_NONE:
			if (_is_over (member->last_atime, M->delay_expire_MASTER))
				return member_action_to_LEAVING(member);
			if (_is_over (member->last_USE, _delay_ping_final(M)))
				defer_USE(member);
			return;

			/* Interruptions */
		case EVT_SYNC_REQ:
			return;
		case EVT_LEAVE_REQ:
			return member_action_to_LEAVING(member);
		case EVT_LEFT_MASTER:
			return member_warn_abnormal_event(member, evt);
		case EVT_LEFT_SELF:
			member_warn("LEFT (self)", member);
			member->myid = -1;
			member_reset_master(member);
			return member_action_to_CREATING(member);

			/* Actions: none should be pending! */

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react_FAILED(struct election_member_s *member, enum event_type_e evt)
{
	_member_assert_FAILED (member);
	const struct election_manager_s *M = member->manager;

	switch (evt) {
		/* Possible time-triggered actions */
		case EVT_NONE:
			if (_is_over (member->last_atime, M->delay_expire_FAILED))
				return member_action_to_LEAVING(member);
			if (_is_over (member->last_status, M->delay_retry_FAILED))
				return member_action_to_CREATING(member);
			if (_is_over (member->last_USE, M->delay_ping_FAILED))
				defer_USE(member);
			return;

			/* Interruptions */
		case EVT_LEAVE_REQ:
			member_reset(member);
			return member_action_to_NONE(member);
		case EVT_SYNC_REQ:
			member->requested_PIPEFROM = 1;
			return;
		case EVT_LEFT_SELF:
			return;
		case EVT_LEFT_MASTER:
			return;

			/* Abnormal events */
		default:
			return member_warn_abnormal_event(member, evt);
	}
}

static void
_member_react (struct election_member_s *member,
		enum event_type_e evt,
		void *evt_arg)
{
	if (GRID_TRACE_ENABLED()) {
		gchar tag[64];
		g_snprintf(tag, sizeof(tag), "evt:%d/%s", evt, _evt2str(evt));
		member_trace(tag, member);
	}

	/* EVT_DISCONNECTED is sent when we lost the link with ZK. All the
	 * ephemeral nodes will be lost, soon. We can reset an elections FSM
	 * receiving this event, whatever it's state. */
	if (evt == EVT_DISCONNECTED) {
		member_reset(member);
		return member_action_to_NONE(member);
	}

	switch (member->step) {
		case STEP_NONE:
			return _member_react_NONE(member, evt);
		case STEP_CREATING:
			return _member_react_CREATING(member, evt, evt_arg);
		case STEP_WATCHING:
			return _member_react_WATCHING(member, evt);
		case STEP_LISTING:
			return _member_react_LISTING(member, evt, evt_arg);
		case STEP_LEAVING:
			return _member_react_LEAVING(member, evt);
		case STEP_LEAVING_FAILING:
			return _member_react_LEAVING_FAILING(member, evt);
		case STEP_ASKING:
			return _member_react_ASKING(member, evt, evt_arg);
		case STEP_CHECKING_MASTER: /* PRELOST */
			return _member_react_CHECKING_MASTER(member, evt);
		case STEP_CHECKING_SLAVES: /* PRELEAD */
			return _member_react_CHECKING_SLAVES(member, evt);
		case STEP_SYNCING:
			return _member_react_SYNCING(member, evt);
		case STEP_SLAVE:
			return _member_react_SLAVE(member, evt);
		case STEP_MASTER:
			return _member_react_MASTER(member, evt);
		case STEP_FAILED:
			return _member_react_FAILED(member, evt);
	}

	g_assert_not_reached();
}

static void
transition(struct election_member_s *member, enum event_type_e evt,
		void *evt_arg)
{
	enum election_step_e pre = member->step;
	_member_react(member, evt, evt_arg);
	enum election_step_e post = member->step;

	if (evt != EVT_NONE || pre != post)
		member_log_event(member, pre, evt);

	/* re-kickoff elections marked as to be restarted, but only if without
	 * activity and if the manager if not being exited. */
	if (member->step == STEP_NONE && BOOL(member->requested_USE)
			&& !member->manager->exiting)
		return transition(member, EVT_NONE, NULL);
}

static void
transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc)
{
	EXTRA_ASSERT(zrc != ZOK);
	if (_zoo_disconnected(zrc))
		return transition(member, EVT_DISCONNECTED, NULL);
	return transition(member, evt, NULL);
}

static GSList *
_DEQUE_extract (struct deque_beacon_s *beacon)
{
	GSList *out = NULL;
	for (struct election_member_s *m=beacon->front; m ;m=m->next)
		out = g_slist_prepend (out, m);
	return g_slist_reverse (out);
}

guint
election_manager_play_timers (struct election_manager_s *manager, guint max)
{
	static const int steps[] = {
		STEP_NONE,
		STEP_FAILED, STEP_MASTER, STEP_SLAVE,
		//STEP_LEAVING,
		STEP_CHECKING_SLAVES, STEP_CHECKING_MASTER, STEP_LISTING, STEP_CREATING,
		-1 /* stops the iteration */
	};

	guint count = 0;

	g_mutex_lock (&manager->lock);
	for (const int *pi=steps; *pi >= 0 && (!max || count < max) ;++pi) {
		struct deque_beacon_s *beacon = manager->members_by_state + *pi;
		if (!beacon->front)
			continue;
		/* working on an item of the list might alterate the list, and even
		   move the item itself to the tail. so working with a temp. list
		   avoids loops and wrong game on pointers. */
		GSList *l0 = _DEQUE_extract (beacon);
		for (GSList *l=l0; l && (!max || count < max) ;l=l->next) {

			struct election_member_s *m = l->data;
			if (m->step == STEP_NONE) {
				if (_is_over(m->last_status, manager->delay_expire_NONE)) {
					/* Election in NONE state for longer than acceptable */
					if (m->refcount == 1) {
						/* In addition, not referenced by anyone */
						count ++;
						_DEQUE_remove (m);
						g_tree_remove (manager->members_by_key, m->key);
						member_unref (m);
						member_destroy (m);
					}
				}
			} else {
				/* Just send a ping */
				enum election_step_e pre = m->step;
				_member_react (m, EVT_NONE, NULL);
				enum election_step_e post = m->step;
				if (pre == post) {
					/* Avoid looping on that item, so let's shift it from the
					 * head then push it to the tail of the queue. */
					_DEQUE_remove (m);
					_DEQUE_add (m);
				}
			}
		}
		g_slist_free (l0);
		l0 = NULL;
	}
	g_mutex_unlock (&manager->lock);

	return count;
}
