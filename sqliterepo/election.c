/*
 * Copyright (C) 2013 AtoS Worldline
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef G_LOG_DOMAIN
# define G_LOG_DOMAIN "grid.sqlx.election"
#endif

#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>

#include <glib.h>
#include <zookeeper/zookeeper.h>

#include "../metautils/lib/lrutree.h"
#include "../metautils/lib/hashstr.h"
#include "../metautils/lib/loggers.h"
#include "../metautils/lib/metatypes.h"
#include "../metautils/lib/metautils.h"
#include "../metautils/lib/metacomm.h"

#include "./internals.h"
#include "./sqliterepo.h"
#include "./hash.h"
#include "./election.h"
#include "./version.h"
#include "./gridd_client.h"
#include "./sqlx_remote.h"
#include "./client_pool.h"

#define EVENTLOG_SIZE 16
#define COND_COUNT 4096
#define STATUS_FINAL(e) ((e) & 0x10)

#define manager_connect(M) zookeeper_init( \
		(M)->config->get_manager_url((M)->config->ctx), \
		zk_main_watch, 4000, NULL, (M), 0)

#define manager_get_member(M,K) lru_tree_get((M)->lrutree_members, (K))

typedef guint req_id_t;
typedef guint req_counter_t;

enum election_step_e
{
	STEP_NONE        = 0x00,
	STEP_CANDREQ     = 0x01,
	STEP_CANDOK      = 0x02,
	STEP_LEAVING     = 0x03,
	STEP_PRELOST     = 0x04,
	STEP_PRELEAD     = 0x05,

	STEP_LOST        = 0x10,
	STEP_LEADER      = 0x11,
	STEP_FAILED      = 0x12,
};


enum event_type_e
{
	EVT_NONE = 0,
	EVT_DISCONNECTED,
	EVT_EXITING,

	EVT_GETVERS_RES,
	EVT_USE_RES,

	EVT_CREATE_OK,
	EVT_CREATE_KO,

	EVT_NODE_LEFT,

	EVT_MASTER_KO,
	EVT_MASTER_EMPTY,
	EVT_MASTER_OK,
	EVT_MASTER_CHANGE,

	EVT_RESYNC_REQ,
	EVT_RESYNC_DONE,

	EVT_LIST_OK,
	EVT_LIST_KO,

	EVT_LEAVE_OK,
	EVT_LEAVE_KO,
};

struct logged_event_s
{
	enum event_type_e event   :8;
	enum election_step_e pre  :8;
	enum election_step_e post :8;
};

struct election_manager_s
{
	time_t delay_max_wait; /*!< how many seconds we accept to wait for a
							    status. */
	time_t delay_write_lock; /*!< how many seconds we may wait for a write
								  lock on an election member. */
	time_t delay_restart_failed; /*!< how many seconds we wait before
									  restarting a failed election. */
	time_t delay_max_idle; /*!< how many seconds we wait before deciding a
							    pending election is stalled. */

	struct sqlx_repository_s *repo;
	zhandle_t *zh;
	clientid_t client_id;

	gboolean exiting;

	gchar zk_prefix[256];
	struct lru_tree_s *lrutree_members; // pending elections
	GMutex *lock;
	GCond *conds[COND_COUNT];

	/* pool'ifies the client sockets to avoid reserving to many file
	 * descriptors. */
	struct client_pool_s *pool;

	/* do not free or change the fields below */
	const struct replication_config_s *config;

	req_id_t next_id;
};

struct election_member_s
{
	struct election_manager_s *manager;
	hashstr_t *key;
	gchar *name;
	gchar *type;

	gboolean exiting;

	guint32 refcount;

	/* election status */
	enum election_step_e step;
	GTimeVal last_status;

	gchar  hashdir[8];
	gint64 myid; /*!< generated by zookeeper */

	gchar *master_url; /*!< First node of the children sequence */
	gint64 master_id; /* !< terminal ID of the master_url */

	struct logged_event_s log[EVENTLOG_SIZE];

	req_id_t reqid_USE;
	req_id_t reqid_PIPEFROM;
	req_id_t reqid_GETVERS;
	req_counter_t errors_GETVERS;
	req_counter_t pending_GETVERS;
	req_counter_t requested_PIPEFROM;
	req_counter_t pending_PIPEFROM;
	req_counter_t sent_GETVERS;
	req_counter_t pending_USE;

	guint log_index;
};

struct result_GETVERS_s
{
	GTree *vdiff;
	GError *err;
	guint reqid;
};

/* ------------------------------------------------------------------------- */

static GQuark gquark_log = 0;

static void transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc);

static void transition(struct election_member_s *member,
		enum event_type_e evt_type, void *evt_arg);

static void defer_PIPEFROM(struct election_member_s *m,
		const gchar *dst, const gchar *src);

static void defer_USE(struct election_member_s *member);

static void defer_GETVERS(struct election_member_s *member);


/* XXX MIsc helpers -------------------------------------------------------- */

static inline void
gtv_init_ago(GTimeVal *ago, time_t delay)
{
	glong d;

	d = delay;
	d = d * -1000000L;
	g_get_current_time(ago);
	g_time_val_add(ago, d);
}

static GArray *
nodev_to_int64v(const struct String_vector *sv, const gchar *prefix)
{
	const gchar *stripe, *s;
	GArray *array;
	int32_t i, max;

	array = g_array_new(0, 0, sizeof(gint64));

	for (i=0,max=sv->count; i<max ;i++) {
		s = sv->data[i];
		if (g_str_has_prefix(s, prefix)) {
			if (NULL != (stripe = strrchr(s,'-'))) {
				gint64 i64 = g_ascii_strtoll(stripe+1, NULL, 10);
				g_array_append_vals(array, &i64, 1);
			}
		}
	}

	if (array->len > 1)
		g_array_sort(array, gint64_sort);

	return array;
}

static const gchar *
_step2str(enum election_step_e step)
{
	switch (step) {
		case STEP_NONE:
			return "NONE";
		case STEP_CANDREQ:
			return "CANDREQ";
		case STEP_CANDOK:
			return "CANDOK";
		case STEP_LEAVING:
			return "LEAVING";
		case STEP_PRELOST:
			return "PRELOST";
		case STEP_PRELEAD:
			return "PRELEAD";
		case STEP_LOST:
			return "LOST";
		case STEP_LEADER:
			return "LEADER";
		case STEP_FAILED:
			return "FAILED";
	}
	return "!INVALID!";
}

static const gchar *
_evt2str(enum event_type_e evt)
{
	switch (evt) {
		case EVT_NONE:
			return "NONE";
		case EVT_DISCONNECTED:
			return "DISCONNECTED";
		case EVT_EXITING:
			return "EXITING";
		case EVT_USE_RES:
			return "USE_RES";
		case EVT_GETVERS_RES:
			return "GETVERS_RES";
		case EVT_CREATE_OK:
			return "CREATE_OK";
		case EVT_CREATE_KO:
			return "CREATE_KO";
		case EVT_NODE_LEFT:
			return "NODE_LEFT";
		case EVT_MASTER_KO:
			return "MASTER_KO";
		case EVT_MASTER_EMPTY:
			return "MASTER_EMPTY";
		case EVT_MASTER_OK:
			return "MASTER_OK";
		case EVT_MASTER_CHANGE:
			return "MASTER_CHANGE";
		case EVT_RESYNC_REQ:
			return "RESYNC_REQ";
		case EVT_RESYNC_DONE:
			return "RESYNC_DONE";
		case EVT_LIST_OK:
			return "LIST_OK";
		case EVT_LIST_KO:
			return "LIST_KO";
		case EVT_LEAVE_OK:
			return "LEAVE_OK";
		case EVT_LEAVE_KO:
			return "LEAVE_KO";
	}

	return "!INVALID!";
}

/* XXX Member handling ----------------------------------------------------- */

#define manager_next_reqid(M) (++ (M)->next_id)
#define member_get_cond(M)    (MMANAGER(M)->conds[hashstr_hash((M)->key) % COND_COUNT])
#define member_get_lock(M)    (MMANAGER(M)->lock)
#define member_has_action(M)  ((M)->pending_GETVERS > 0 || (M)->pending_PIPEFROM > 0)
#define member_lock(M)      g_mutex_lock(member_get_lock(M))
#define member_unlock(M)    g_mutex_unlock(member_get_lock(M))
#define member_signal(M)    g_cond_signal(member_get_cond(M))
#define member_wait(M,max)  g_cond_timed_wait(member_get_cond(M), member_get_lock(M), max)
#define member_get_peers(M) MCFG(M)->get_peers(MCFG(M)->ctx, (M)->name, (M)->type)
#define member_get_url(M)   MCFG(M)->get_local_url(MCFG(M)->ctx)
#define member_ref(M) do { ++ (M)->refcount; } while (0)
#define member_unref(M) do { SQLX_ASSERT((M)->refcount > 0); -- (M)->refcount; } while (0)

#define member_reset(M) do { \
	if ((M)->master_url) { \
		g_free((M)->master_url); \
		(M)->master_url = NULL; \
	} \
	(M)->sent_GETVERS = (M)->errors_GETVERS = (M)->reqid_GETVERS = \
	(M)->reqid_PIPEFROM = (M)->pending_GETVERS = (M)->pending_PIPEFROM = 0; \
	(M)->myid = (M)->master_id = -1; \
} while (0)

#define member_set_id(M,id) do { \
	SQLX_ASSERT(id >= 0); \
	SQLX_ASSERT((M)->myid <= 0); \
	(M)->myid = id; \
	member_debug(__FUNCTION__, "ID", (M)); \
} while (0)

#define member_set_status(M,S) do { \
	g_get_current_time(&((M)->last_status)); \
	(M)->step = (S); \
	if (STATUS_FINAL(S)) { \
		member_debug(__FUNCTION__, "FINAL", (M)); \
		member_signal(M); \
	} \
	else if ((S) == STEP_NONE) { \
		member_signal(M); \
	} \
} while (0)

#define member_reset_master(M) do { \
	(M)->master_id = -1; \
	if ((M)->master_url) \
		g_free((M)->master_url); \
	(M)->master_url = NULL; \
} while (0)

#define member_set_master_url(M,U) do { \
	if ((M)->master_url) { \
		g_free((M)->master_url); \
		(M)->master_url = NULL; \
	} \
	if (U) { \
		(M)->master_url = g_strdup(U); \
	} \
	member_debug(__FUNCTION__, "MASTER_URL", (M)); \
} while (0)

#define member_set_master_id(M,mid) do { \
	gint64 i64 = mid; \
	SQLX_ASSERT(i64 >= 0); \
	if (i64 != (M)->master_id) \
		member_reset_master(M); \
	(M)->master_id = i64; \
	member_debug(__FUNCTION__, "MASTER_ID", (M)); \
} while (0)

static void
member_log_event(struct election_member_s *member, enum election_step_e pre,
		enum event_type_e evt)
{
	struct logged_event_s *plog;
	plog = member->log + ((member->log_index++) % EVENTLOG_SIZE);
	plog->event = evt;
	plog->pre = pre;
	plog->post = member->step;
}

static gchar*
member_dump_log(struct election_member_s *member)
{
	GString *out;

	out = g_string_new("\n\tP: ");

	/* local url */
	do {
		const gchar *myurl = member_get_url(member);
		g_string_append(out, myurl);
	} while (0);

	/* the peers */
	do {
		gchar **p, **peers;
		for (p = peers = member_get_peers(member); p && *p ;p++) {
			g_string_append_c(out, '|');
			g_string_append(out, *p);
		}
		if (peers)
			g_strfreev(peers);
	} while (0);

	/* then the livelog */
	do {
		guint i, idx;
		struct logged_event_s *plog;

		idx = member->log_index - 1;
		for (i=0; i<EVENTLOG_SIZE ;i++,idx--) {
			plog = member->log + (idx % EVENTLOG_SIZE);
			if (!plog->pre && !plog->post)
				break;
			g_string_append_printf(out, "\n\t%s:%s:%s",
					_step2str(plog->pre),
					_evt2str(plog->event),
					_step2str(plog->post));
		}
	} while (0);

	return g_string_free(out, FALSE);
}

static void
member_descr(const struct election_member_s *m, gchar *d, gsize ds)
{
	g_snprintf(d, ds,
			"%s [%"G_GINT64_FORMAT"/%"G_GINT64_FORMAT"/%s] %u/%u/%u/%u [%.*s] [%s.%s]",
			_step2str(m->step), m->myid, m->master_id, m->master_url,
			m->refcount, m->pending_USE, m->pending_GETVERS, m->pending_PIPEFROM,
			hashstr_ulen(m->key), hashstr_str(m->key),
			m->name, m->type);
}

static void
member_trace(const gchar *func, const gchar *tag,
		const struct election_member_s *m)
{
	(void) func;
	(void) tag;
	(void) m;
#ifdef HAVE_EXTRA_DEBUG
	gchar d[256];
	if (!GRID_TRACE2_ENABLED())
		return;
	member_descr(m, d, sizeof(d));
	GRID_TRACE2("%s %s %s", tag ? tag : "", d, func ? func : "");
#endif
}

static void
member_debug(const gchar *func, const gchar *tag,
		const struct election_member_s *m)
{
	gchar d[256];
	member_descr(m, d, sizeof(d));
	GRID_DEBUG("%s %s %s", tag ? tag : "", d, func ? func : "");
}

static void
member_warn(const gchar *tag, const struct election_member_s *m)
{
	gchar d[256];
	member_descr(m, d, sizeof(d));
	GRID_WARN("%s %s", tag ? tag : "", d);
}


static struct election_member_s *
member_create(struct election_manager_s *manager,
		const gchar *name, const gchar *type,
		const struct hashstr_s *key)
{
	guint w;
	GTimeVal now;
	struct election_member_s *result;

	g_get_current_time(&now);
	MANAGER_CHECK(manager);

	result = g_malloc0(sizeof(*result));
	result->manager = manager;
	result->exiting=FALSE;
	memcpy(&(result->last_status), &now, sizeof(now));
	result->key = hashstr_dup(key);
	result->name = g_strdup(name);
	result->type = g_strdup(type);
	result->myid = result->master_id = -1;

	switch (CLAMP(manager->config->hash_depth, 0, 2)) {
		case 0:
			break;
		case 1:
			w = CLAMP(manager->config->hash_width, 1, 3);
			g_snprintf(result->hashdir, sizeof(result->hashdir),
					"%.*s", w, hashstr_str(key));
			break;
		default:
			w = CLAMP(manager->config->hash_width, 1, 2);
			g_snprintf(result->hashdir, sizeof(result->hashdir), "%.*s/%.*s",
					w, hashstr_str(key), w, hashstr_str(key) + w);
			break;
	}

	return result;
}

static gchar *
member_dirname(struct election_member_s *member)
{
	return g_strconcat(member->manager->zk_prefix,
			member->hashdir[0] ? "/" : NULL,
			member->hashdir, NULL);
}

static gchar *
member_fullpath(struct election_member_s *member)
{
	return (member->myid >= 0)
		? g_strdup_printf("%s/%s%s%s-%010"G_GINT64_FORMAT,
				member->manager->zk_prefix,
				member->hashdir, member->hashdir[0] ? "/" : "",
				hashstr_str(member->key), member->myid)
		: g_strdup_printf("%s/%s%s%s-",
				member->manager->zk_prefix,
				member->hashdir, member->hashdir[0] ? "/" : "",
				hashstr_str(member->key));
}

static gchar *
member_masterpath(struct election_member_s *member)
{
	return (member->master_id < 0) ? NULL
		: g_strdup_printf("%s/%s%s%s-%010"G_GINT64_FORMAT,
				member->manager->zk_prefix,
				member->hashdir, member->hashdir[0] ? "/" : "",
				hashstr_str(member->key), member->master_id);
}

static void
member_destroy(struct election_member_s *member)
{
	if (!member)
		return;

	if (member->master_url)
		g_free(member->master_url);
	if (member->key)
		g_free(member->key);
	if (member->name)
		g_free(member->name);
	if (member->type)
		g_free(member->type);

	memset(member, 0, sizeof(*member));
	member->myid = member->master_id = -1;
	g_free(member);
}

static gboolean
member_group_master(struct election_member_s *member, GArray *i64v)
{
	SQLX_ASSERT(i64v != NULL);
	SQLX_ASSERT(i64v->len > 0);
	if (member->myid < 0)
		return FALSE;
	return g_array_index(i64v, gint64, 0) == member->myid;
}

static gboolean
member_in_group(struct election_member_s *member, GArray *i64v)
{
	guint i;
	gint64 i64;

	SQLX_ASSERT(i64v != NULL);
	if (member->myid < 0)
		return FALSE;
	for (i=0; i<i64v->len ;i++) {
		i64 = g_array_index(i64v, gint64, i);
		if (i64 == member->myid)
			return TRUE;
	}
	return FALSE;
}

static gboolean
member_pending_for_too_long(struct election_member_s *member)
{
	GTimeVal ago;

	switch (member->step) {
		case STEP_NONE:
			return FALSE;
		case STEP_CANDREQ:
		case STEP_CANDOK:
		case STEP_PRELOST:
		case STEP_PRELEAD:
			gtv_init_ago(&ago, member->manager->delay_max_idle);
			return gtv_bigger(&ago, &(member->last_status));
		case STEP_LEAVING:
		case STEP_LEADER:
		case STEP_LOST:
		case STEP_FAILED:
			return FALSE;
	}

	g_assert_not_reached();
	return FALSE;
}

static gboolean
member_failed_for_too_long(struct election_member_s *member)
{
	GTimeVal ago;

	if (member->step != STEP_FAILED)
		return FALSE;
	gtv_init_ago(&ago, member->manager->delay_restart_failed);
	return gtv_bigger(&ago, &(member->last_status));
}

static struct election_member_s *
manager_init_member(struct election_manager_s *manager,
		const gchar *name, const gchar *type)
{
	struct election_member_s *member;
	struct hashstr_s *key;

	MANAGER_CHECK(manager);

	key = sqliterepo_hash_name(name, type);
	member = manager_get_member(manager, key);
	if (!member) {
		member = member_create(manager, name, type, key);
		lru_tree_insert(manager->lrutree_members, hashstr_dup(key), member);
	}
	g_free(key);
	member_ref(member);
	return member;
}

static guint
manager_count_active(struct election_manager_s *manager)
{
	guint count;
	gboolean _count(gpointer k, gpointer v, gpointer u) {
		enum election_step_e step;
		(void) k; (void) u;
		MEMBER_CHECK(v);
		step = MEMBER(v)->step;
		if (step != STEP_NONE && step != STEP_FAILED)
			++ count;
		return FALSE;
	}

	count = 0;
	g_mutex_lock(manager->lock);
	lru_tree_foreach_TREE(manager->lrutree_members, _count, NULL);
	g_mutex_unlock(manager->lock);
	return count;
}

static void
manager_send_EXITING(struct election_manager_s *manager)
{
	gboolean send_exit(gpointer k, gpointer v, gpointer u) {
		(void) k; (void) u;
		MEMBER_CHECK(v);
		if (MEMBER(v)->step != STEP_NONE)
			transition(v, EVT_EXITING, NULL);
		return FALSE;
	}

	lru_tree_foreach_TREE(manager->lrutree_members, send_exit, NULL);
	GRID_INFO("EXIT order sent");
}

void
election_manager_exit_all(struct election_manager_s *manager, GTimeVal *max)
{
	GTimeVal now;
	guint count;

	GRID_INFO("Voluntarily exiting all the elections...");
	MANAGER_CHECK(manager);

	/* Order the node to exit */
	g_mutex_lock(manager->lock);
	manager->exiting = TRUE;
	manager_send_EXITING(manager);
	g_mutex_unlock(manager->lock);

	while (0 < (count = manager_count_active(manager))) {
		GRID_INFO("Waiting for %u active elections", count);
		g_get_current_time(&now);
		if (max && gtv_bigger(&now, max)) {
			GRID_WARN("TIMEOUT while waiting for active elections");
			return;
		}
		usleep(500000);
	}
	GRID_INFO("No more active elections");
}

void
election_manager_whatabout(struct election_manager_s *m,
		const gchar *name, const gchar *type, gchar *d, gsize ds)
{
	struct election_member_s *member;
	hashstr_t *key;

	MANAGER_CHECK(m);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);
	SQLX_ASSERT(d != NULL);
	SQLX_ASSERT(ds > 0);

	key = sqliterepo_hash_name(name, type);
	g_mutex_lock(m->lock);
	member = manager_get_member(m, key);
	if (member) {
		gchar *log;

		member_descr(member, d, ds);
		log = member_dump_log(member);
		g_strlcat(d, log, ds);
		g_free(log);
	}
	else
		g_snprintf(d, ds, "Not found");
	g_mutex_unlock(m->lock);

	g_free(key);
}

/* XXX Zookeeper callbacks ------------------------------------------------- */

static void
step_AskMaster_completion(int zrc, const char *v, int vlen,
		const struct Stat *s, const void *d)
{
	gchar *master = NULL;
	struct election_member_s *member;

	(void) s;
	member = d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	master = (v && vlen && *v) ? g_strndup(v, vlen) : NULL;

	member_lock(member);
	if (zrc != ZOK) {
		transition_error(member, EVT_MASTER_KO, zrc);
	}
	else {
		if (!master) {
			transition(member, EVT_MASTER_EMPTY, &zrc);
		}
		else {
			transition(member, EVT_MASTER_OK, master);
		}
	}
	member_unref(member);
	member_unlock(member);

	if (master)
		g_free(master);
}

static void
step_ListGroup_completion(int zrc, const struct String_vector *sv,
		const void *data)
{
	struct election_member_s *member;

	member = data;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);

	if (zrc != ZOK) {
		transition_error(member, EVT_LIST_KO, zrc);
	}
	else {
		GArray *i64v = nodev_to_int64v(sv, hashstr_str(member->key));
		transition(member, EVT_LIST_OK, i64v);
		g_array_free(i64v, TRUE);
	}

	member_unref(member);
	member_unlock(member);
}

static void
step_LeaveElection_completion(int zrc, const void *d)
{
	struct election_member_s *member;

	member = d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc != ZOK) {
		if (zrc == ZNONODE) {
			transition(member, EVT_LEAVE_OK, NULL);
		}
		else {
			transition_error(member, EVT_LEAVE_KO, zrc);
		}
	}
	else {
		transition(member, EVT_LEAVE_OK, NULL);
	}
	member_unref(member);
	member_unlock(member);
}

static void
step_WatchNode_completion(int zrc, const struct Stat *stat, const void *d)
{
	struct election_member_s *member;

	(void) stat;

	member = d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc != ZOK) {
		if (zrc == ZNONODE) {
			transition(member, EVT_NODE_LEFT, &zrc);
		}
		else {
			transition_error(member, EVT_NONE, zrc);
		}
	}
	member_unref(member);
	member_unlock(member);
}

static void
step_StartElection_completion(int zrc, const char *path, const void *d)
{
	gint64 i64;
	struct election_member_s *member;

	member = d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "DONE", member);

	member_lock(member);
	if (zrc != ZOK) {
		transition_error(member, EVT_CREATE_KO, zrc);
	}
	else {
		if (!path) {
			transition(member, EVT_CREATE_KO, &zrc);
		}
		else {
			i64 = g_ascii_strtoll(strrchr(path, '-')+1, NULL, 10);
			transition(member, EVT_CREATE_OK, &i64);
		}
	}
	member_unref(member);
	member_unlock(member);
}

/* XXX Zookeeper monitors -------------------------------------------------- */

static void
step_WatchMaster_change(zhandle_t *handle, int type, int state,
			const char *path, void *d)
{
	struct election_member_s *member;

	(void) handle;
	(void) type;
	(void) state;
	(void) path;

	member = d;
	member_trace(__FUNCTION__, "CHANGE", member);
	MEMBER_CHECK(member);

	member_lock(member);
	transition(member, EVT_MASTER_CHANGE, NULL);
	member_unref(member);
	member_unlock(member);
}

static void
step_WatchNode_change(zhandle_t *handle, int type, int state,
		const char *path, void *d)
{
	struct election_member_s *member;

	(void) handle;
	(void) type;
	(void) state;
	(void) path;

	member = d;
	MEMBER_CHECK(member);
	member_trace(__FUNCTION__, "CHANGE", member);

	member_lock(member);
	transition(member, EVT_NODE_LEFT, NULL);
	member_unref(member);
	member_unlock(member);
}

/* ------------------------------------------------------------------------- */

static int
step_StartElection_start(struct election_member_s *member)
{
	const gchar *myurl;
	gchar *path;
	int zrc;

	member_trace(__FUNCTION__, "ACTION", member);

	myurl = member_get_url(member);
	path = member_fullpath(member);
	zrc = zoo_acreate(member->manager->zh,
			path, myurl, strlen(myurl),
			&ZOO_OPEN_ACL_UNSAFE, ZOO_EPHEMERAL|ZOO_SEQUENCE,
			step_StartElection_completion, member);
	g_free(path);

	if (zrc == ZOK) {
		member_ref(member);
	}
	return zrc;
}

static int
step_AskMaster_start(struct election_member_s *member)
{
	int zrc = ZNONODE;
	gchar *path = NULL;

	member_trace(__FUNCTION__, "ACTION", member);

	if (NULL != (path = member_masterpath(member))) {
		zrc = zoo_awget(member->manager->zh, path,
				step_WatchMaster_change, member,
				step_AskMaster_completion, member);
		g_free(path);
		if (zrc == ZOK) {
			member_ref(member);
			member_ref(member);
		}
	}

	return zrc;
}

static int
step_WatchNode_start(struct election_member_s *member)
{
	int zrc = ZNONODE;
	gchar *path = NULL;

	member_trace(__FUNCTION__, "ACTION", member);

	if (NULL != (path = member_fullpath(member))) {
		zrc = zoo_awexists(member->manager->zh, path,
				step_WatchNode_change, member,
				step_WatchNode_completion, member);
		g_free(path);
		if (zrc == ZOK) {
			member_ref(member);
			member_ref(member);
		}
	}

	return zrc;
}

static int
step_ListGroup_start(struct election_member_s *member)
{
	int zrc;
	gchar *path;

	member_trace(__FUNCTION__, "ACTION", member);

	path = member_dirname(member);
	zrc = zoo_awget_children(member->manager->zh, path,
			NULL, NULL,
			step_ListGroup_completion, member);
	g_free(path);

	if (zrc == ZOK) {
		member_ref(member);
	}

	return zrc;
}

static int
step_LeaveElection_start(struct election_member_s *member)
{
	int zrc;
	gchar *path;

	member_trace(__FUNCTION__, "ACTION", member);

	path = member_fullpath(member);
	zrc = zoo_adelete(member->manager->zh, path, -1,
			step_LeaveElection_completion, member);
	g_free(path);

	if (zrc == ZOK)
		member_ref(member);
	return zrc;
}


/* ------------------------------------------------------------------------- */


static void
zk_main_watch(zhandle_t *zh, int type, int state, const char *path,
		void *watcherCtx)
{
	const gchar *zkurl;
	struct election_manager_s *manager;

	GRID_INFO("%s(%p,%d,%d,%s,%p)", __FUNCTION__,
			zh, type, state, path, watcherCtx);

	manager = watcherCtx;
	MANAGER_CHECK(manager);
	zkurl = manager->config->get_manager_url(manager->config->ctx);

	if (type == ZOO_SESSION_EVENT) {
		if (state == ZOO_CONNECTING_STATE) {
			g_mutex_lock(manager->lock);
			manager->exiting = TRUE;
			manager_send_EXITING(manager);
			zookeeper_close(manager->zh);
			manager->exiting = FALSE;
			manager->zh = manager_connect(manager);
			if (!manager->zh) {
				GRID_ERROR("ZooKeeper init failure: (%d) %s",
						errno, strerror(errno));
				abort();
			}
			g_mutex_unlock(manager->lock);
		}
	}
	else {
		if (state == ZOO_EXPIRED_SESSION_STATE) {
			GRID_WARN("Zookeeper: expired session to [%s]", zkurl);
		}
		else if (state == ZOO_AUTH_FAILED_STATE) {
			GRID_WARN("Zookeeper: auth problem to [%s]", zkurl);
		}
		else if (state == ZOO_CONNECTING_STATE) {
			GRID_WARN("Zookeeper: (re)connecting to [%s]", zkurl);
		}
		else if (state == ZOO_ASSOCIATING_STATE) {
			GRID_DEBUG("Zookeeper: associating to [%s]", zkurl);
		}
		else if (state == ZOO_CONNECTED_STATE) {
			memcpy(&(manager->client_id), zoo_client_id(zh),
					sizeof(manager->client_id));
			GRID_INFO("Zookeeper: connected to [%s] id=%"G_GINT64_FORMAT,
					zkurl, manager->client_id.client_id);
		}
	}
}


/* ------------------------------------------------------------------------- */

GError *
election_manager_trigger_RESYNC(struct election_manager_s *manager,
		const gchar *name, const gchar *type)
{
	struct election_member_s *member;

	MANAGER_CHECK(manager);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);

	g_mutex_lock(manager->lock);
	member = manager_init_member(manager, name, type);
	transition(member, EVT_RESYNC_REQ, NULL);
	member_unref(member);
	g_mutex_unlock(manager->lock);

	return NULL;
}

void
election_init(struct election_manager_s *manager, const gchar *name,
		const gchar *type)
{
	struct election_member_s *member;

	MANAGER_CHECK(manager);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);

	if (!election_has_peers(manager, name, type)) {
		GRID_DEBUG("Unable to find peers for [%s][%s]", name, type);
		return ;
	}

	g_mutex_lock(manager->lock);
	member = manager_init_member(manager, name, type);
	member_unref(member);
	g_mutex_unlock(manager->lock);
}

void
election_start(struct election_manager_s *m, const gchar *name,
		const gchar *type)
{
	struct election_member_s *member;

	MANAGER_CHECK(m);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);

	if (!election_has_peers(m, name, type)) {
		GRID_DEBUG("Unable to find peers for [%s][%s]", name, type);
		return ;
	}

	g_mutex_lock(m->lock);
	member = manager_init_member(m, name, type);
	member->exiting=FALSE;
	transition(member, EVT_NONE, NULL);
	member_unref(member);
	g_mutex_unlock(m->lock);
}

gboolean
election_has_peers(struct election_manager_s *manager,
		const gchar *name, const gchar *type)
{
	gboolean rc = FALSE;

	MANAGER_CHECK(manager);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);

	gchar **peers = manager->config->get_peers(manager->config->ctx,
			name, type);
	if (!peers)
		return FALSE;
	rc = g_strv_length(peers) > 0;
	g_strfreev(peers);
	return rc;
}

void
election_exit(struct election_manager_s *m, const gchar *name,
                const gchar *type)
{
	struct election_member_s *member;

	MANAGER_CHECK(m);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);

	g_mutex_lock(m->lock);
	member = manager_init_member(m, name, type);
	member->exiting=TRUE;
	transition(member, EVT_EXITING, NULL);
	member_unref(member);
	g_mutex_unlock(m->lock);
}


enum election_status_e
election_get_status(struct election_manager_s *m, const gchar *name,
		const gchar *type, gchar **master_url)
{
	GTimeVal max;
	int rc, wait_rc;
	gchar *url = NULL;
	struct election_member_s *member;

	MANAGER_CHECK(m);
	SQLX_ASSERT(name != NULL);
	SQLX_ASSERT(type != NULL);

	g_get_current_time(&max);
	g_time_val_add(&max, 1000000L * m->delay_max_wait);

	g_mutex_lock(m->lock);
	member = manager_init_member(m, name, type);

	transition(member, EVT_NONE, NULL); /* kickoff! */

	for (wait_rc=TRUE; wait_rc && !STATUS_FINAL(member->step) ;) {

		if (member_pending_for_too_long(member)) {
			wait_rc = FALSE;
			GRID_WARN("TIMEOUT! (pending) [%s.%s]", name, type);
		}
		else {
			GRID_TRACE("Still waiting for a final status on [%s.%s]", name, type);

			transition(member, EVT_NONE, NULL); /* kickoff! */
			if (!(wait_rc = member_wait(member, &max)))
				GRID_WARN("TIMEOUT! (wait) [%s.%s]", name, type);
		}
	}

	if (!wait_rc) { /* TIMEOUT! */
		rc = STEP_FAILED;
	}
	else {
		rc = member->step;
		if (rc == STEP_LOST) {
			if (member->master_url)
				url = g_strdup(member->master_url);
		}
	}

	member_unref(member);
	if (rc == STEP_NONE || STATUS_FINAL(rc))
		member_signal(member);
	member_unlock(member);

	GRID_TRACE("STEP=%s/%d master=%s", _step2str(rc), rc, url);
	switch (rc) {
		case STEP_LEADER:
			return ELECTION_LEADER;
		case STEP_LOST:
			if (master_url)
				*master_url = url;
			else
				g_free(url);
			url = NULL;
			return ELECTION_LOST;
		default:
			return ELECTION_FAILED;
	}
}

GError *
election_manager_create(struct replication_config_s *config,
		struct sqlx_repository_s *repo, struct election_manager_s **result)
{
	int i;
	struct election_manager_s *manager;

	if (!gquark_log)
		gquark_log = g_quark_from_static_string(G_LOG_DOMAIN);

	GRID_TRACE2("%s(%p,%p)", __FUNCTION__, config, result);
	CONFIG_CHECK(config);
	SQLX_ASSERT(repo != NULL);
	SQLX_ASSERT(result != NULL);

	zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);
	manager = g_malloc0(sizeof(*manager));
	manager->repo = repo;
	manager->delay_write_lock = 5;
	manager->delay_restart_failed = 2;
	manager->delay_max_idle = 30;
	manager->delay_max_wait = 5;
	manager->config = config;

	g_snprintf(manager->zk_prefix, sizeof(manager->zk_prefix),
			"/hc/ns/%s/%s", config->get_ns_name(config->ctx),
			(config->subpath ? config->subpath : "el"));

	manager->pool = client_pool_create(2);
	if (!manager->pool) {
		g_free(manager);
		return g_error_new(gquark_log, 0, "Sockets pool creation failure");
	}

	manager->lrutree_members = lru_tree_create(
			(GCompareFunc)hashstr_quick_cmp,
			g_free, (GDestroyNotify)member_destroy, 0);

	manager->lock = g_mutex_new();
	for (i=0; i<COND_COUNT ;i++)
		manager->conds[i] = g_cond_new();

	if (!(manager->zh = manager_connect(manager)))
		return g_error_new(gquark_log, errno,
				"ZooKeeper init failure: %s", strerror(errno));

	*result = manager;
	return NULL;
}

void
election_manager_clean(struct election_manager_s *manager)
{
	int i;

	if (!gquark_log)
		gquark_log = g_quark_from_static_string(G_LOG_DOMAIN);

	if (!manager)
		return;

	if (manager->zh)
		zookeeper_close(manager->zh);

	if (manager->pool)
		client_pool_destroy(manager->pool);

	if (manager->lrutree_members)
		lru_tree_destroy(manager->lrutree_members);

	if (manager->lock)
		g_mutex_free(manager->lock);

	for (i=0; i<COND_COUNT ;i++) {
		if (manager->conds[i])
			g_cond_free(manager->conds[i]);
	}

	memset(manager, 0, sizeof(*manager));
	g_free(manager);
}

gboolean
election_manager_configured(const struct election_manager_s *mgr)
{
	const struct replication_config_s *cfg;

	return ((cfg = election_manager_get_config(mgr)) != NULL)
		&& (cfg->mode != ELECTION_MODE_NONE);
}

const struct replication_config_s *
election_manager_get_config(const struct election_manager_s *manager)
{
	return manager ? manager->config : NULL;
}

static GSList*
_get_to_be_notified(struct election_manager_s *manager, GTimeVal *pivot)
{
	GSList *res = NULL;

	gint _sort_by_status(gconstpointer p0, gconstpointer p1) {
		const GTimeVal *tv0, *tv1;

		tv0 = &(MEMBER(p0)->last_status);
		tv1 = &(MEMBER(p1)->last_status);
		return gtv_bigger(tv1, tv0) ? 1 : (gtv_bigger(tv0, tv1) ? -1 : 0);
	}

	gboolean _traverse(gpointer k, gpointer v, gpointer u) {
		struct election_member_s *m = v;
		(void) k;
		(void) u;
		switch (m->step) {
			case STEP_NONE:
				return FALSE;
			case STEP_CANDREQ:
			case STEP_CANDOK:
			case STEP_LEAVING:
			case STEP_PRELOST:
			case STEP_PRELEAD:
				if (!pivot || gtv_bigger(pivot, &(m->last_status)))
					res = g_slist_prepend(res, m);
			case STEP_LOST:
			case STEP_LEADER:
			case STEP_FAILED:
				return FALSE;
		}
		return FALSE;
	}

	lru_tree_foreach_TREE(manager->lrutree_members, _traverse, NULL);
	return g_slist_sort(res, _sort_by_status);
}

guint
election_manager_retry_elections(struct election_manager_s *manager,
		guint max, GTimeVal *pivot, GTimeVal *end)
{
	guint count;
	GTimeVal now;
	GSList *l, *to_be_notified = NULL;

	MANAGER_CHECK(manager);
	if (!gquark_log)
		gquark_log = g_quark_from_static_string(G_LOG_DOMAIN);

	GRID_TRACE2("%s(%p,%u,%p,%p)", __FUNCTION__, manager, max, pivot, end);

	if (manager->exiting)
		return 0;

	/* Generate the list of members to be notified */
	g_mutex_lock(manager->lock);
	to_be_notified = _get_to_be_notified(manager, pivot);

	for (count=0,l=to_be_notified; l ;l=l->next) {
		struct election_member_s *m = l->data;
		g_get_current_time(&now);
		if (end && gtv_bigger(&now, end))
			break;
		if (max && count >= max)
			break;
		transition(m, EVT_NONE, NULL);
		count ++;
	}

	g_mutex_unlock(manager->lock);

	g_slist_free(to_be_notified);
	return count;
}

GError *
election_manager_clients_round(struct election_manager_s *m, time_t max)
{
	MANAGER_CHECK(m);
	if (!gquark_log)
		gquark_log = g_quark_from_static_string(G_LOG_DOMAIN);
	return client_pool_round(m->pool, max);
}


/* ------------------------------------------------------------------------- */

struct udata_USE_s
{
	guint reqid;
	struct election_member_s *member;
};

static void
on_end_USE(struct event_client_s *mc)
{
	struct udata_USE_s *udata;
	struct election_member_s *member;
	GError *err;

	SQLX_ASSERT(mc != NULL);
	SQLX_ASSERT(mc->client != NULL);
	SQLX_ASSERT(mc->udata != NULL);
	udata = mc->udata;
	SQLX_ASSERT(udata->member != NULL);
	member = udata->member;

	MEMBER_CHECK(member);
	err = gridd_client_error(mc->client);

	member_lock(member);
	transition(member, EVT_USE_RES, &(udata->reqid));
	member_unlock(member);

	if (err)
		g_error_free(err);
	g_free(udata);
}

static void
defer_USE(struct election_member_s *member)
{
	gchar **peers, **p;
	guint pending = 0;
	struct sqlx_name_s n;

	n.ns = "";
	n.base = member->name;
	n.type = member->type;

	peers = member_get_peers(member);

	if (!peers || !*peers)
		pending = 0;
	else {
		if (member->pending_USE)
			pending = 0;
		else
			pending = g_strv_length(peers);
	}

	if (!pending)
		member_trace(__FUNCTION__, "USE avoided", member);
	else {
		GByteArray *req;

		member->pending_USE = pending;
		member->reqid_USE = manager_next_reqid(member->manager);

		req = sqlx_pack_USE(&n);
		for (p=peers; p && *p ;p++) {
			struct udata_USE_s *udata;
			struct event_client_s *mc;

			member_ref(member);
			udata = g_malloc0(sizeof(*udata));
			udata->reqid = member->reqid_USE;
			udata->member = member;
			mc = g_malloc0(sizeof(*mc));
			mc->on_end = on_end_USE;
			mc->client = gridd_client_create(*p, req, NULL, NULL);
			mc->udata = udata;
			client_pool_defer(member->manager->pool, mc);
		}
		g_byte_array_unref(req);

		member_trace(__FUNCTION__, "USE scheduled", member);
	}

	if (peers)
		g_strfreev(peers);
}

/* ------------------------------------------------------------------------- */

static void
on_end_PIPEFROM(struct event_client_s *mc)
{
	GError *err;
	struct election_member_s *member;

	SQLX_ASSERT(mc != NULL);
	SQLX_ASSERT(mc->udata != NULL);
	member = mc->udata;
	SQLX_ASSERT(member->manager != NULL);
	SQLX_ASSERT(member->key != NULL);

	err = gridd_client_error(mc->client);
	GRID_DEBUG("PIPEFROM result [%s.%s] [%s]: (%d) %s",
			member->name, member->type,
			hashstr_str(member->key), err?err->code:0, err?err->message:"OK");

	member_lock(member);
	transition(member, EVT_RESYNC_DONE, &(member->reqid_PIPEFROM));
	member_unref(member);
	member_unlock(member);

	if (err)
		g_error_free(err);
}

static void
defer_PIPEFROM(struct election_member_s *member,
		const gchar *target, const gchar *source)
{
	guint pending = 0;

	MEMBER_CHECK(member);
	SQLX_ASSERT(target != NULL);
	SQLX_ASSERT(source != NULL);

	pending = member->pending_PIPEFROM ? 0 : 1;

	if (!pending)
		member_debug(__FUNCTION__, "PIPEFROM avoided", member);
	else {
		struct event_client_s *mc;
		struct sqlx_name_s n;
		n.ns = "";
		n.base = member->name;
		n.type = member->type;

		member->reqid_PIPEFROM = manager_next_reqid(member->manager);
		member->pending_PIPEFROM = pending;
		member->requested_PIPEFROM = 0;

		GByteArray *req = sqlx_pack_PIPEFROM(&n, source);
		member_ref(member);
		mc = g_malloc0(sizeof(*mc));
		mc->client = gridd_client_create(target, req, NULL, NULL);
		mc->on_end = on_end_PIPEFROM;
		mc->udata = member;
		g_byte_array_unref(req);

		client_pool_defer(member->manager->pool, mc);

		member_debug(__FUNCTION__, "PIPEFROM scheduled", member);
	}
}

/* ------------------------------------------------------------------------- */

struct udata_GETVERS_s
{
	guint reqid;
	struct election_member_s *member;
	GTree *version;
};

static void
on_end_GETVERS(struct event_client_s *mc)
{
	struct election_member_s *member;
	struct udata_GETVERS_s *udata;
	GError *err = NULL;
	GTree *vdiff = NULL;

	SQLX_ASSERT(mc != NULL);
	SQLX_ASSERT(mc->client != NULL);
	SQLX_ASSERT(mc->udata != NULL);
	udata = mc->udata;
	SQLX_ASSERT(udata->member != NULL);
	member = udata->member;
	MEMBER_CHECK(member);

	err = gridd_client_error(mc->client);

	if (err)
		member_debug(err->message, "GETVERS result", member);

	if (!err) {
		if (!udata->version)
			err = g_error_new(gquark_log, 500, "BUG: no version received");
	}
	if (!err) {
		/* Get the current version of the local base, and compare it to the
		 * version received from the peer */
		GTree *vlocal = NULL, *vremote = NULL;
		vremote = udata->version;
		udata->version = NULL;
		err = sqlx_repository_get_version2(member->manager->repo,
				member->type, member->name, &vlocal);
		if (!err && !vlocal)
			err = g_error_new(gquark_log, 500, "API BUG! no version returned");
		if (err) {
			GRID_WARN("Failed to get the base version: (%d) %s",
					err->code, err->message);
			g_clear_error(&err);
		}
		else
			err = version_diff(&vdiff, vlocal, vremote);
		if (vlocal)
			g_tree_destroy(vlocal);
		if (vremote)
			g_tree_destroy(vremote);
	}

	struct result_GETVERS_s res;
	res.err = err;
	res.vdiff = vdiff;
	res.reqid = udata->reqid;
	member_lock(member);
	transition(member, EVT_GETVERS_RES, &res);
	member_unlock(member);

	g_free(udata);
	if (err)
		g_clear_error(&err);
	if (vdiff)
		g_tree_destroy(vdiff);
}

static gboolean
on_reply_GETVERS(gpointer ctx, struct message_s *reply)
{
	struct event_client_s *ec;
	struct udata_GETVERS_s *udata;
	void *b = NULL;
	gsize bsize = 0;

	GRID_TRACE2("%s(%p,%p)", __FUNCTION__, ctx, reply);
	SQLX_ASSERT(reply != NULL);
	ec = ctx;
	SQLX_ASSERT(ec != NULL);
	udata = ec->udata;
	SQLX_ASSERT(udata != NULL);

	if (0 < message_get_BODY(reply, &b, &bsize, NULL)) {
		GTree *version;

		if (!(version = version_decode(b, bsize))) {
			GRID_WARN("Invalid encoded version in reply");
			return FALSE;
		}

		if (udata->version)
			g_tree_destroy(udata->version);
		udata->version = version;
	}

	return TRUE;
}

static void
defer_GETVERS(struct election_member_s *member)
{
	guint pending = 0;
	gchar **peers, **p;

	MEMBER_CHECK(member);
	GRID_TRACE2("%s(%p)", __FUNCTION__, member);

	if (!(peers = member_get_peers(member))) {
		GRID_INFO("Failed to get the peers for [%s][%s]",
				member->name, member->type);
		return;
	}

	pending = member->pending_GETVERS ? 0 : g_strv_length(peers);

	if (!pending)
		member_debug(__FUNCTION__ ,"GETVERS avoided", member);
	else {
		struct sqlx_name_s n;
		n.ns = "";
		n.base = member->name;
		n.type = member->type;

		member->sent_GETVERS = pending;
		member->pending_GETVERS = pending;
		member->reqid_GETVERS = manager_next_reqid(member->manager);

		GByteArray *req = sqlx_pack_GETVERS(&n);
		for (p=peers; p && *p ;p++) {
			struct event_client_s *mc;
			struct udata_GETVERS_s udata;

			member_ref(member);
			udata.reqid = member->reqid_GETVERS;
			udata.version = NULL;
			udata.member = member;
			mc = g_malloc0(sizeof(*mc));
			mc->on_end = on_end_GETVERS;
			mc->udata = g_memdup(&udata, sizeof(udata));
			mc->client = gridd_client_create(*p, req, mc, on_reply_GETVERS);
			client_pool_defer(member->manager->pool, mc);
		}
		g_byte_array_unref(req);

		member_trace(__FUNCTION__ ,"GETVERS scheduled", member);
	}

	g_strfreev(peers);
}


/* ------------------------------------------------------------------------ */

static void
become_leaver(struct election_member_s *member)
{
	member_set_status(member, STEP_LEAVING);
	int zrc = step_LeaveElection_start(member);
	if (zrc != ZOK)
		member_set_status(member, STEP_FAILED);
}

#define become_candidate(M) do { \
	member_reset_master((M)); \
	member_set_status((M), STEP_CANDOK); \
	if (ZOK != step_ListGroup_start((M))) \
		member_set_status((M), STEP_FAILED); \
} while (0)

#define manage_deleted(M) do { \
	member_warn("DELETED", (M)); \
	/* restart_election((M)); */ \
	become_leaver(M); \
} while (0)

static void
restart_election(struct election_member_s *member)
{
	int zrc;

	member_reset(member);
	if (member->manager->exiting || member->exiting ) {
		member_set_status(member, STEP_NONE);
		return;
	}
	member_set_status(member, STEP_CANDREQ);
	defer_USE(member);
	zrc = step_StartElection_start(member);
	if (ZOK != zrc) {
		GRID_WARN("CREATE failed [%s.%s] [%s] : (%d) %s",
				member->name, member->type, hashstr_str(member->key),
				zrc, zerror(zrc));
		member_set_status(member, STEP_FAILED);
	}
}

static void
manage_list(struct election_member_s *member, GArray *i64v)
{
	int zrc;
	SQLX_ASSERT(i64v != NULL);

	member_set_status(member, STEP_CANDOK);

	if (!member_in_group(member, i64v)) {
		member_trace(__FUNCTION__, "DISAPPEARED", member);
		restart_election(member);
	}
	else {
		if (member_group_master(member, i64v)) {
			member_set_master_id(member, member->myid);
			member_set_status(member, STEP_PRELEAD);
			defer_GETVERS(member);
		}
		else {
			member_set_master_id(member, g_array_index(i64v, gint64, 0));
			member_set_status(member, STEP_PRELOST);
			zrc = step_AskMaster_start(member);
			if (zrc != ZOK) {
				GRID_WARN("AskMaster failed [%s.%s] [%s] : (%d) %s",
						member->name, member->type, hashstr_str(member->key),
						zrc, zerror(zrc));
				become_leaver(member);
			}
			else {
				defer_GETVERS(member);
			}
		}
	}
}

static void
member_cleanup(struct election_member_s *member)
{
	const gchar *local_url;

	if (!member->master_url) {
		member->requested_PIPEFROM = 1;
		GRID_TRACE2("CLEANUP not yet possible, no master known");
	}
	else if (member->pending_PIPEFROM) {
		member->requested_PIPEFROM = 1;
		GRID_TRACE2("CLEANUP deferred, already running");
	}
	else {
		local_url = member->manager->config->get_local_url(
				member->manager->config->ctx);
		defer_PIPEFROM(member, local_url, member->master_url);
		GRID_DEBUG("CLEANUP asked");
	}
}

static void
_transition(struct election_member_s *member, enum event_type_e evt,
		void *evt_arg)
{
	gchar tag[256];
	guint reqid;
	int zrc;
	guint outdated_GETVERS = 0;

	MEMBER_CHECK(member);
	g_snprintf(tag, sizeof(tag), "EVENT:%s", _evt2str(evt));
	member_debug(__FUNCTION__, tag, member);

	switch (evt) {
		case EVT_DISCONNECTED:
			member_reset(member);
			member_set_status(member, STEP_FAILED);
			return;
		case EVT_USE_RES:
			SQLX_ASSERT(evt_arg != NULL);
			reqid = *((guint*)evt_arg);
			if (reqid == member->reqid_USE) {
				if (member->pending_USE > 0)
					-- member->pending_USE;
			}
			if (!member->pending_USE)
				member->reqid_USE = 0;
			break;
		case EVT_GETVERS_RES:
			do {
				struct result_GETVERS_s *res;
				SQLX_ASSERT(evt_arg != NULL);
				res = evt_arg;
				if (res->reqid == member->reqid_GETVERS) {
					if (member->pending_GETVERS > 0) {
						-- member->pending_GETVERS;
						if (res->err || !res->vdiff)
							++ member->errors_GETVERS;
						else {
							gint64 worst = version_diff_worst(res->vdiff);
							/*GRID_WARN("GETVERS DIFF %"G_GINT64_FORMAT, worst);*/
							if (worst > 0)
								++ outdated_GETVERS;
						}
					}
				}
				if (!member->pending_GETVERS)
					member->reqid_GETVERS = 0;
			} while (0);
			break;
		case EVT_RESYNC_DONE:
			SQLX_ASSERT(evt_arg != NULL);
			reqid = *((guint*)evt_arg);
			if (reqid == member->reqid_PIPEFROM) {
				-- member->pending_PIPEFROM;
				if (!member->pending_PIPEFROM)
					member->reqid_PIPEFROM = 0;
			}
			break;
		default:
			break;
	}

	switch (member->step) {

		case STEP_NONE:
			if (evt == EVT_NONE || evt == EVT_RESYNC_REQ)
				restart_election(member);
			return;

		case STEP_CANDREQ:
			switch (evt) {
				case EVT_RESYNC_REQ:
					member_cleanup(member);
					return;
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_CREATE_OK:
					SQLX_ASSERT(evt_arg != NULL);
					member_set_id(member, *((gint64*)evt_arg));
					if (ZOK != step_WatchNode_start(member))
						member_set_status(member, STEP_FAILED);
					else
						become_candidate(member);
					return;
				case EVT_CREATE_KO:
					zrc = *((int*)evt_arg);
					GRID_WARN("CREATE failed [%s.%s] [%s] : (%d) %s",
							member->name, member->type, hashstr_str(member->key),
							zrc, zerror(zrc));
					member_set_status(member, STEP_FAILED);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_CANDOK:
			switch (evt) {
				case EVT_RESYNC_REQ:
					member_cleanup(member);
					return;
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_LIST_OK:
					manage_list(member, evt_arg);
					return;
				case EVT_LIST_KO:
				case EVT_NODE_LEFT:
					become_candidate(member);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_PRELOST:
			switch (evt) {

				case EVT_RESYNC_REQ:
					member_cleanup(member);
				case EVT_NONE:
				case EVT_DISCONNECTED:
				case EVT_USE_RES:
					return;

				case EVT_CREATE_OK:
				case EVT_CREATE_KO:
				case EVT_LEAVE_OK:
				case EVT_LEAVE_KO:
				case EVT_LIST_OK:
				case EVT_LIST_KO:
					member_warn("ABNORMAL", member);
				case EVT_NODE_LEFT:
				case EVT_MASTER_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
					become_candidate(member);
					return;

				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_MASTER_OK:
					SQLX_ASSERT(evt_arg != NULL);
					member_set_master_url(member, (gchar*)evt_arg);
					if (member->requested_PIPEFROM)
						member_cleanup(member);
					if (!member_has_action(member))
						member_set_status(member, STEP_LOST);
					return;
				case EVT_GETVERS_RES:
					if (outdated_GETVERS)
						member->requested_PIPEFROM = 1;
					if (member->requested_PIPEFROM)
						member_cleanup(member);
					if (!member_has_action(member) && member->master_url)
						member_set_status(member, STEP_LOST);
					return;
				case EVT_RESYNC_DONE:
					if (!member_has_action(member) && member->master_url)
						member_set_status(member, STEP_LOST);
					return;
			}
			return;

		case STEP_PRELEAD:
			switch (evt) {
				case EVT_RESYNC_REQ:
				case EVT_EXITING:
					become_leaver(member);
				case EVT_NONE:
				case EVT_DISCONNECTED:
				case EVT_USE_RES:
					return;
				case EVT_CREATE_OK:
				case EVT_CREATE_KO:
				case EVT_NODE_LEFT:
				case EVT_MASTER_OK:
				case EVT_MASTER_KO:
				case EVT_LIST_OK:
				case EVT_LIST_KO:
				case EVT_LEAVE_OK:
				case EVT_LEAVE_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
				case EVT_RESYNC_DONE:
					become_candidate(member);
					return;
				case EVT_GETVERS_RES:
					if (outdated_GETVERS)
						become_leaver(member);
					else if (!member_has_action(member))
						member_set_status(member, STEP_LEADER);
					return;
			}
			return;

		case STEP_LEAVING:
			switch (evt) {
				case EVT_RESYNC_REQ:
					member_cleanup(member);
					return;
				case EVT_NODE_LEFT:
				case EVT_LEAVE_OK:
					GRID_INFO("LEFT election [%s.%s]", member->name, member->type);
					restart_election(member);
					return;
				case EVT_LEAVE_KO:
					become_leaver(member);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_LOST:
			switch (evt) {
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_NODE_LEFT:
					manage_deleted(member);
					return;
				case EVT_MASTER_KO:
				case EVT_MASTER_EMPTY:
				case EVT_MASTER_CHANGE:
					become_candidate(member);
					return;
				case EVT_RESYNC_REQ:
					member_cleanup(member);
					member_set_status(member, STEP_PRELOST);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_LEADER:
			switch (evt) {
				case EVT_RESYNC_REQ:
				case EVT_EXITING:
					become_leaver(member);
					return;
				case EVT_NODE_LEFT:
					manage_deleted(member);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;

		case STEP_FAILED:
			switch (evt) {
				case EVT_NONE:
					if (member_failed_for_too_long(member))
						restart_election(member);
					return;
				case EVT_RESYNC_REQ:
					restart_election(member);
					member_cleanup(member);
					return;
				case EVT_CREATE_KO:
				case EVT_NODE_LEFT:
					member_reset(member);
					member_set_status(member, STEP_FAILED);
					return;
				default:
					member_trace("IGNORED", tag, member);
					return;
			}
			return;
	}
}

static void
transition(struct election_member_s *member, enum event_type_e evt,
		void *evt_arg)
{
	enum election_step_e pre, post;

	pre = member->step;
	_transition(member, evt, evt_arg);
	post = member->step;

	if (evt != EVT_NONE || pre != post)
		member_log_event(member, pre, evt);

	if (member->requested_PIPEFROM)
		member_cleanup(member);
}

static void
transition_error(struct election_member_s *member,
		enum event_type_e evt, enum ZOO_ERRORS zrc)
{
	SQLX_ASSERT(zrc <= ZSYSTEMERROR || zrc <= ZAPIERROR);

	if (zrc < ZAPIERROR)
		transition(member, evt, &zrc);
	else if (zrc < ZSYSTEMERROR)
		transition(member, EVT_DISCONNECTED, &zrc);
	else {
		g_assert_not_reached();
	}
}

void
election_manager_clients_setmax(struct election_manager_s *m, guint max)
{
	g_assert(m != NULL);
	if (m->pool)
		client_pool_set_max(m->pool, max);
}

